<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习笔记—离线环境下安装Docker</title>
    <link href="/2024/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Docker/"/>
    <url>/2024/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85Docker/</url>
    
    <content type="html"><![CDATA[<h2 id="离线环境下安装Docker"><a href="#离线环境下安装Docker" class="headerlink" title="离线环境下安装Docker"></a>离线环境下安装Docker</h2><p>&emsp;&emsp;离线场景下配置服务器是一个少见的情况，但有些地方出于安全等考虑服务器并不会接外网，因此，离线部署一些软件是很有意义的。<br><br>&emsp;&emsp;首先需要下载一个合适的docker离线的tgz包，以docker-24.0.9.tgz为例子。<br><br>&emsp;&emsp;当传上服务器后，解压。<br></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf docker-<span class="hljs-number">24</span>.<span class="hljs-number">0</span>.<span class="hljs-number">9</span>.tgz<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;解压后找到docker目录，将docker二进制文件复制到&#x2F;usr&#x2F;bin目录下。<br></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp docker<span class="hljs-regexp">/* /u</span>sr<span class="hljs-regexp">/bin/</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;创建docker的systemd服务文件，以docker.service为例子。<br></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>docker.service<br></code></pre></td></tr></table></figure><p>填入以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Docker Application<br><span class="hljs-attr">Documentation</span>=http://docs.dock.com<br><span class="hljs-attr">After</span>=network-<span class="hljs-literal">on</span>line.target firewalld.service<br><span class="hljs-attr">Wants</span>=network-<span class="hljs-literal">on</span>line.target<br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=notify<br><span class="hljs-attr">ExecStart</span>=/usr/bin/dockerd<br><span class="hljs-attr">ExecReload</span>=/bin/kill -s HUP <span class="hljs-variable">$MAINPID</span><br><span class="hljs-attr">LimitNOFILE</span>=infinity<br><span class="hljs-attr">LimitNPROC</span>=infinity<br><span class="hljs-attr">LimitCORE</span>=infinity<br><span class="hljs-attr">TimeoutStartSec</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">Delegate</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">KillMode</span>=process<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">StartLimitBurst</span>=<span class="hljs-number">3</span><br><span class="hljs-attr">StartLimitInterval</span>=<span class="hljs-number">60</span>s<br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;以上是一个systemd服务单元文件，用于在基于systemd的linux系统上配置和管理Docker服务。<br><br>&emsp;&emsp;Unit中，Description: 描述服务的作用，这里是 “Docker Application”，表示这是用于运行 Docker 应用程序的服务。ocumentation: 提供服务的文档链接，这里是 Docker 的官方文档链接。After: 指定该服务在哪些服务启动之后启动。这里指定了 network-online.target 和 firewalld.service，意味着 Docker 服务会在网络在线和防火墙服务启动之后启动。Wants: 表示该服务希望某个服务启动，但不严格要求它。这里指定了 network-online.target，意味着 Docker 服务希望网络服务在线，但不是严格依赖。<br><br>&emsp;&emsp;Service中，Type: 定义服务启动类型。notify 表示服务会发送一个通知信号来告知 systemd 它已经启动完成。ExecStart: 指定启动服务时要执行的命令。这里是 &#x2F;usr&#x2F;bin&#x2F;dockerd，即启动 Docker 守护进程。ExecReload: 指定重新加载服务配置时要执行的命令。这里是发送 HUP 信号给主进程。LimitNOFILE: 设置服务可以打开的最大文件数，infinity 表示没有限制。LimitNPROC: 设置服务可以创建的最大进程数，infinity 表示没有限制。LimitCORE: 设置服务可以创建的最大核心转储文件大小，infinity 表示没有限制。TimeoutStartSec: 定义启动服务时的超时时间，0 表示没有超时限制。Delegate: 表示将服务管理委派给 Docker 守护进程，让 Docker 管理其子进程。KillMode: 定义如何杀死服务。process 表示只杀死主进程，不杀死其子进程。Restart: 定义服务失败时的重启策略。on-failure 表示只有在服务非正常退出时才重启。StartLimitBurst: 设置在 StartLimitInterval 时间内允许的最大启动次数。StartLimitInterval: 设置启动次数限制的时间间隔。<br><br>&emsp;&emsp;Install中，WantedBy: 指定该服务属于哪个目标。multi-user.target 表示该服务应该在多用户系统环境中启动。<br><br>&emsp;&emsp;这样的一个服务单元配置文件配置了Docker服务的基本行为，比如启动命令、重启策略、依赖关系等等，使得Docker服务能够被systemd正确地管理和启动。<br><br>&emsp;&emsp;紧接着，首先，给Docker的服务单元文件增加执行权限，让systemd能通过执行这个文件来启动Docker服务。<br></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod +x <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>docker.service<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;daemon-reload用于告诉systemd重新加载所有服务单元文件。确保systemd用最新的配置<br></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl daemon-reload</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;启动docker服务。<br></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;将 Docker 服务设置为在系统启动时自动启动。<br></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker.service<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这样，Docker就被离线安装好了。<br><br>&emsp;&emsp;安装完成后，可以通过以下命令来验证 Docker 是否安装成功：<br></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果 Docker 安装成功，该命令将输出 Docker 的版本信息。<br><br>&emsp;&emsp;如果 Docker 安装失败，可以尝试重新安装 Docker，或者查看 Docker 的日志文件（通常位于 &#x2F;var&#x2F;log&#x2F;docker.log）以获取更多错误信息。<br></p><h2 id="离线环境下安装docker-compose"><a href="#离线环境下安装docker-compose" class="headerlink" title="离线环境下安装docker-compose"></a>离线环境下安装docker-compose</h2><p>&emsp;&emsp;Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。它使用 YAML 文件来配置应用程序的服务，并使用一个命令来启动所有服务。<br><br>&emsp;&emsp;在离线环境下安装 Docker Compose，需要先下载 Docker Compose 的二进制文件，然后将其复制到系统的 PATH 中。<br><br>&emsp;&emsp;首先，需要从 Docker 官方网站下载 Docker Compose 的二进制文件。可以在浏览器中打开以下链接：<br></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/</span>compose/releases<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;在页面中找到适合你操作系统的 Docker Compose 版本，并下载对应的二进制文件。以docker-compose-linux-x86_64为例。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> docker-compose-linux-x86_64 /usr/bin/docker-compose<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;先移动至系统可执行目录<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /usr/bin/docker-compose<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;赋予执行权限<br><br>&emsp;&emsp;安装完成后，可以通过以下命令来验证 Docker Compose 是否安装成功：<br></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose -v</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果 Docker Compose 安装成功，该命令将输出 Docker Compose 的版本信息。<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离线环境</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(1)—注册中心与配置中心</title>
    <link href="/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-1-%E2%80%94%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-1-%E2%80%94%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="什么是注册中心"><a href="#什么是注册中心" class="headerlink" title="什么是注册中心"></a>什么是注册中心</h3><p>&emsp;&emsp;注册中心是Spring Cloud和Spring Cloud Alibaba系列的第一步。服务的注册与发现是最基本的操作。<br><br>&emsp;&emsp;在微服务中，注册中心主要体现为三种角色。首先是服务注册中心，也就是Registry，用于保存服务提供者的注册信息，当服务提供者的节点发生变更的时候，注册中心也会同步的变更，服务消费者在感知到这个变更后，会刷新本地内存中所缓存的服务节点列表。<br><br>&emsp;&emsp;第二就是服务提供者（server），服务提供者在自身启动的时候，向Registry注册服务，并向注册中心定期发送心跳来确保注册中心认为该服务还活着。<br><br>&emsp;&emsp;最后，是服务消费者，启动的时候，服务消费者会从注册中心订阅服务，把注册中心返回的服务节点列表缓存在本地内存中，由此来和服务提供者建立联系。<br><br>&emsp;&emsp;服务消费者从本地缓存的服务节点列表中，基于负载均衡算法选择一个服务提供者的示例来发起调用。<br></p><h3 id="常见的注册中心与注册中心需要的功能"><a href="#常见的注册中心与注册中心需要的功能" class="headerlink" title="常见的注册中心与注册中心需要的功能"></a>常见的注册中心与注册中心需要的功能</h3><p>&emsp;&emsp;由此，对于一个服务注册中心来说，首先，需要有一个服务注册的API接口，让服务的提供者通过调用该接口完成服务注册。<br><br>&emsp;&emsp;需要一个心跳检查的接口，服务提供方定期通过该接口汇报自身的服务状态。<br><br>&emsp;&emsp;此外，还需要一些如服务的查询、变更查询、注销等接口。<br><br>&emsp;&emsp;常见的注册中心比如nacos，eureka，zookeeper，ETCD等等。此处详细留痕常用的spring cloud的eureka和spring cloud alibaba的nacos。<br></p><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><h4 id="什么是Eureka"><a href="#什么是Eureka" class="headerlink" title="什么是Eureka"></a>什么是Eureka</h4><p>&emsp;&emsp;Eureka是Netflix开源的服务发现框架，Spring Cloud对其进行了集成，并提供了良好的支持。Eureka分为Eureka Server和Eureka Client，Eureka Server是注册中心，Eureka Client是服务提供者和服务消费者。<br><br>&emsp;&emsp;Eureka Server需要配置一个端口，用于接收Eureka Client的注册请求，同时，Eureka Server需要配置一个地址，用于接收Eureka Client的查询请求。<br></p><h4 id="Eureka的架构"><a href="#Eureka的架构" class="headerlink" title="Eureka的架构"></a>Eureka的架构</h4><p>&emsp;&emsp;从总体来说，Eureka是一个CS架构的东西。主要由两个组件组成，Eureka Server与Eureka Client。Eureka Server是服务注册中心，用于存储所有可用的服务实例信息。Eureka Client是应用程序的客户端，用于向Eureka Server注册服务并查找其他服务。<br><br>&emsp;&emsp;在Eureka中，每个服务都可以注册为一个Eureka Client，并将自己的信息注册到Eureka Server中。当服务启动时，它会向Eureka Server发送一个心跳，告诉Eureka Server自己还活着。如果Eureka Server在一段时间内没有收到心跳，它将自动将该服务从注册表中删除。<br></p><h4 id="Eureka的流程"><a href="#Eureka的流程" class="headerlink" title="Eureka的流程"></a>Eureka的流程</h4><p>&emsp;&emsp;首先是启动Server。<br><br>&emsp;&emsp;接着是启动Client。<br><br>&emsp;&emsp;服务启动后，Client会向Server注册自己的信息，发送一个包含服务实例ID，服务主机名端口，服务健康状态，服务元数据登的POST请求。<br><br>&emsp;&emsp;当Eureka Server收到这些消息后，就会储存这些消息实例的信息到服务注册表里。<br><br>&emsp;&emsp;其他服务可以通过Eureka Client以负载均衡的方式发现其他可用实例并选择一个进行请求。<br><br>&emsp;&emsp;服务实例可能会在运行的过程中更改其状态，例如服务实例的健康状态可能会更改。当服务实例状态更改时，服务会向Eureka Server发送一个PUT请求，以更新其状态信息。Eureka Server将根据收到的信息更新服务实例的状态。<br><br>&emsp;&emsp;当服务实例停止时，服务实例会向Eureka Server发送一个DELETE请求，以从注册表中删除自己的信息。Eureka Server将根据收到的信息从注册表中删除该服务实例的信息。<br></p><h4 id="Eureka的实践"><a href="#Eureka的实践" class="headerlink" title="Eureka的实践"></a>Eureka的实践</h4><p>&emsp;&emsp;Eureka是集成进spring cloud了的，因此，使用起来非常简单。<br></p><h5 id="Eureka服务端"><a href="#Eureka服务端" class="headerlink" title="Eureka服务端"></a>Eureka服务端</h5><p>&emsp;&emsp;首先需要有一个Eureka的服务端。通过IDEA快速创建Spring Boot项目，并且选择Eureka服务端，也可在Pom文件添加响应的依赖。（此外，还需要web相关的依赖，来确保eureka的服务端可以正常使用）<br><br>&emsp;&emsp;创建成功后，在spring boot的启动类上加入Eureka服务端的注解。<br></p><figure class="highlight less"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableEurekaServer</span><br>public class EurekaServerApplication &#123;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(EurekaServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;配置文件如下：<br></p><figure class="highlight ini"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server.port</span>=<span class="hljs-number">8761</span><br><span class="hljs-attr">spring.application.name</span>=eureka<br><span class="hljs-attr">eureka.instance.hostname</span>=localhost<br><span class="hljs-attr">eureka.instance.prefer-ip-address</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">eureka.server.wait-time-in-ms-when-sync-empty</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">eureka.server.enable-self-preservation</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">eureka.server.eviction-interval-timer-in-ms</span>=<span class="hljs-number">60000</span><br><span class="hljs-attr">eureka.client.register-with-eureka</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">eureka.client.fetch-registry</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">eureka.client.instance-info-replication-interval-seconds</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">eureka.client.registry-fetch-interval-seconds</span>=<span class="hljs-number">30</span><br><span class="hljs-attr">eureka.client.service-url.defaultZone</span>=http://<span class="hljs-variable">$&#123;eureka.instance.hostname&#125;</span>:<span class="hljs-variable">$&#123;server.port&#125;</span>/eureka<br><span class="hljs-attr">eureka.instance.instance-id</span>=<span class="hljs-variable">$&#123;spring.application.name&#125;</span>:<span class="hljs-variable">$&#123;spring.cloud.client.ip-address&#125;</span>:<span class="hljs-variable">$&#123;spring.application.instance_id:$&#123;server.port&#125;</span>&#125;<br><span class="hljs-attr">eureka.instance.lease-expiration-duration-in-seconds</span>=<span class="hljs-number">90</span><br><span class="hljs-attr">management.endpoints.web.exposure.include</span>=*<br><span class="hljs-attr">management.endpoint.health.show-details</span>=always<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;通用的不表，eureka.instance.prefer-ip-address&#x3D;true是指示Eureka注册服务时，优先使用IP地址而不是主机名。<br><br>&emsp;&emsp;eureka.server.wait-time-in-ms-when-sync-empty&#x3D;0表示的是Eureka服务器在启动阶段同步注册信息的时候，如果注册信息是空的，那么服务器所需要等待的时间（毫秒）。一般默认是5分钟。<br><br>&emsp;&emsp;eureka.server.enable-self-preservation&#x3D;false是用于控制Eureka服务器是否启用自我保护模式。在自我保护模式下，Eureka会保护服务注册表中的信息，即使出现网络分区也不会注销任何服务实例。<br><br>&emsp;&emsp;eureka.server.eviction-interval-timer-in-ms&#x3D;60000设置Eureka服务器清理无效服务实例的时间间隔（毫秒）。<br><br>&emsp;&emsp;eureka.client.register-with-eureka&#x3D;true用于指示客户端是否向Eureka注册自己。<br><br>&emsp;&emsp;eureka.client.instance-info-replication-interval-seconds&#x3D;10设置客户端将实例信息复制到Eureka服务器的间隔时间（秒）。<br><br>&emsp;&emsp;eureka.client.registry-fetch-interval-seconds&#x3D;30设置客户端从Eureka服务器获取注册信息的间隔时间（秒）。<br><br>&emsp;&emsp;eureka.instance.lease-expiration-duration-in-seconds&#x3D;90设置Eureka客户端续租到期时间（秒），即服务实例在多少秒内没有向Eureka服务器发送心跳，服务器会将该实例从注册表中删除。<br><br>&emsp;&emsp;如图所示为eureka注册中心的显示。<br><br><img src="/../imgs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%BE%AE%E6%9C%8D%E5%8A%A1_%E6%B3%A8%E5%86%8C%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/Eureka%E7%95%8C%E9%9D%A2.png" alt="Eureka注册中心" title="Eureka注册中心"><br>&emsp;&emsp;当想要自己对Eureka做操作时，通常可采用Eureka REST API或者编程方式。<br></p><h5 id="Eureka客户端"><a href="#Eureka客户端" class="headerlink" title="Eureka客户端"></a>Eureka客户端</h5><p>&emsp;&emsp;客户端也非常容易。<br><br>&emsp;&emsp;还是使用IDEA创建Spring Boot项目，并且选择Eureka客户端依赖，也可在Pom中直接添加。<br><br>&emsp;&emsp;随后配置Eureka的服务端地址，还是采用Properties格式如下。<br></p><figure class="highlight ini"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server.port</span>=<span class="hljs-number">8889</span><br><span class="hljs-attr">spring.application.name</span>=eureka-client<br><span class="hljs-attr">eureka.client.service-url.defaultZone</span>=http://localhost:<span class="hljs-number">8761</span>/eureka/<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;随后在启动类添加:<br></p><figure class="highlight less"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableDiscoveryClient</span><br>public class EurekaServerApplication &#123;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(EurekaServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;启动后，访问Eureka注册中心，可以看到Eureka客户端已经注册到Eureka服务器上。(还是JAVA在这里好用哇……)<br></p><h5 id="Eureka的REST-API"><a href="#Eureka的REST-API" class="headerlink" title="Eureka的REST API"></a>Eureka的REST API</h5><figure class="highlight gradle"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">GET <span class="hljs-regexp">/eureka/</span>apps：获取所有注册的应用程序和实例信息。<br>GET <span class="hljs-regexp">/eureka/</span>apps/&#123;appID&#125;：获取指定应用程序的所有实例信息。<br>GET <span class="hljs-regexp">/eureka/</span>apps<span class="hljs-regexp">/&#123;appID&#125;/</span>&#123;instanceID&#125;：获取指定应用程序和实例的详细信息。<br>POST <span class="hljs-regexp">/eureka/</span>apps/&#123;appID&#125;：注册一个新的应用程序实例。<br>PUT <span class="hljs-regexp">/eureka/</span>apps<span class="hljs-regexp">/&#123;appID&#125;/</span>&#123;instanceID&#125;：更新指定应用程序和实例的信息。<br><span class="hljs-keyword">DELETE</span> <span class="hljs-regexp">/eureka/</span>apps<span class="hljs-regexp">/&#123;appID&#125;/</span>&#123;instanceID&#125;：注销指定应用程序和实例。<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如图所示为请求&#x2F;eureka&#x2F;apps获得注册信息的图片。其他同理。<br><br><img src="/../imgs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%BE%AE%E6%9C%8D%E5%8A%A1_%E6%B3%A8%E5%86%8C%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/eureka%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF.png" alt="Eureka的注册信息API获取" title="Eureka的注册信息API获取"></p><h5 id="Eureka的编程方式"><a href="#Eureka的编程方式" class="headerlink" title="Eureka的编程方式"></a>Eureka的编程方式</h5><p>&emsp;&emsp;首先需要确保项目中包含了Eureka的客户端依赖。<br></p><figure class="highlight xml"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;然后就可以采用类似于如下的编程方式，来获得Eureka现在的相关信息。<br><br>&emsp;&emsp;首先是Service：<br></p><figure class="highlight typescript"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscoveryService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">DiscoveryClient</span> discoveryClient;<br><br>    <span class="hljs-comment">// 获得对应服务的实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">ServiceInstance</span>&gt; <span class="hljs-title function_">getServiceInstances</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> serviceName</span>) &#123;<br>        <span class="hljs-keyword">return</span> discoveryClient.<span class="hljs-title function_">getInstances</span>(serviceName);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有服务ID</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">getAllServices</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> discoveryClient.<span class="hljs-title function_">getServices</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有服务的所有服务实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">ServiceInstance</span>&gt;&gt; <span class="hljs-title function_">getAllServiceInstances</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAllServices</span>().<span class="hljs-title function_">stream</span>()<br>                .<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toMap</span>(<br>                        serviceId -&gt; serviceId,<br>                        <span class="hljs-attr">this</span>::getServiceInstances<br>                ));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;调用对应接口如下：<br><br><img src="/../imgs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%BE%AE%E6%9C%8D%E5%8A%A1_%E6%B3%A8%E5%86%8C%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/eureka_service.png" alt="编程方式获取Eureka的服务注册信息" title="编程方式获取Eureka的服务注册信息"><br><img src="/../imgs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%BE%AE%E6%9C%8D%E5%8A%A1_%E6%B3%A8%E5%86%8C%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/eureka_%E5%AE%9E%E4%BE%8B.png" alt="编程方式获取Eureka的某个服务的实例信息" title="编程方式获取Eureka的某个服务的实例信息"></p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><h4 id="什么是Nacos"><a href="#什么是Nacos" class="headerlink" title="什么是Nacos"></a>什么是Nacos</h4><p>&emsp;&emsp;Nacos是阿里巴巴开源的一个动态服务发现、配置管理和服务管理平台。Nacos提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos就是注册中心+配置中心，可以取代Eureka+Config。<br></p><h4 id="Nacos的安装"><a href="#Nacos的安装" class="headerlink" title="Nacos的安装"></a>Nacos的安装</h4><p>&emsp;&emsp;Nacos的安装非常简单，只需要下载解压即可，下载地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br><br>&emsp;&emsp;下载完成后，进入bin目录，执行以下命令启动Nacos：<br></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;启动完成后，访问<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a><br><br>&emsp;&emsp;即可看到Nacos的界面。<br><br>&emsp;&emsp;此外，还可以采用Docker或Kubernetes的相关方式来安装启动nacos，暂按不表。<br></p><h4 id="Nacos的实践"><a href="#Nacos的实践" class="headerlink" title="Nacos的实践"></a>Nacos的实践</h4><p>&emsp;&emsp;Nacos的实践与Eureka类似，这里不再赘述，详见Eureka的实践。<br><br>&emsp;&emsp;值得注意的是，@EnableDiscoveryClient这样一个注解，不止适用于Eureka作为注册中心，还适用于如Nacos等其他注册中心来使用。<br></p><h4 id="Nacos的Open-API"><a href="#Nacos的Open-API" class="headerlink" title="Nacos的Open API"></a>Nacos的Open API</h4><p>&emsp;&emsp;与Eureka相似，Nacos也提供一系列OpenAPI可供操作，详见Nacos OpenAPI指南：<a href="https://nacos.io/zh-cn/docs/open-api.html">https://nacos.io/zh-cn/docs/open-api.html</a><br></p><h4 id="Nacos的编程方式"><a href="#Nacos的编程方式" class="headerlink" title="Nacos的编程方式"></a>Nacos的编程方式</h4><p>&emsp;&emsp;Nacos的编程方式与Eureka相似，参见：<a href="https://github.com/gagaducko/springboot-nacosapi-example">https://github.com/gagaducko/springboot-nacosapi-example</a><br><br>&emsp;&emsp;此处为一个采用Nacos编程方式对注册中心信息进行获取与管理的示例，这里不再赘述。<br></p><h3 id="Nacos与Eureka的优劣"><a href="#Nacos与Eureka的优劣" class="headerlink" title="Nacos与Eureka的优劣"></a>Nacos与Eureka的优劣</h3><p>&emsp;&emsp;Eureka专注于服务的注册与发现，而nacos即是注册中心，也是配置中心，支持动态的配置管理。在生态上，Nacos除了与Spring Cloud有良好的兼容性外，同时也支持Spring Cloud Alibaba生态系统，也适合在Kubernetes环境下部署使用。<br><br>&emsp;&emsp;此外，在扩展性上，Eureka支持水平扩展，在CAP中是AP模型，遵循高可用性，即便是部分节点通信失败也能继续注册和发现，缺点在于极端情况下节点的数据可能就会不一样了，短时间内不同步。而Nacos则支持AP与CP两种模式，即可选择高可用，也可以选择强一致。Nacos 在集群模式下可以通过 Raft 一致性协议保证强一致性<br><br>&emsp;&emsp;另外，Eureka相对来说比较轻量级，适合服务数量较少的场景，而Nacos则适合大规模的微服务集群开发，内存和储存消耗较高但是性能和功能的扩展性更强，对于多语言的支持也更好。<br></p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><h3 id="为什么需要配置中心"><a href="#为什么需要配置中心" class="headerlink" title="为什么需要配置中心"></a>为什么需要配置中心</h3><p>&emsp;&emsp;配置文件是一个很让人熟悉的东西，尤其是对于Spring Boot项目来说，完善配置文件是相当重要的，比如Mysql在项目中的配置，Redis在项目中的配置，以及其他的一些可能会变更的配置。<br><br>&emsp;&emsp;对于一些复杂的环境下，当修改配置后，必须重启服务，否则配置无法生效，这是相当麻烦的，因此，这种省事儿的配置方法是不太好的，最好是能够直接在一个地方修改配置文件，项目读取这个配置文件，省去在配置信息有所变化的情况下，不断打包打镜像重启的繁杂工作。<br></p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>&emsp;&emsp;Spring Cloud Config是spring cloud家族中最早的配置 中心，也分为配置中心服务端和配置中心客户端。<br><br>&emsp;&emsp;通过集成Spring Cloud Config，可以采用数据库、SVN、本地文件等作为配置的储存，以下就三块来做一下Config的实践。<br></p><h4 id="实现最简单的配置中心服务端"><a href="#实现最简单的配置中心服务端" class="headerlink" title="实现最简单的配置中心服务端"></a>实现最简单的配置中心服务端</h4><p>&emsp;&emsp;当使用Spring Cloud Config的情况下，可以加入如此依赖来实验一个config的服务端。<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;而后在启动类上注入:<br></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableConfigServer</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;接着在配置文件中做配置，可以采用git的方式，也可以采用本地的方式。<br><br>&emsp;&emsp;如git:<br></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.application.name</span>=spring-cloud-config-server<br><span class="hljs-attr">server.port</span>=<span class="hljs-number">8080</span><br><br><span class="hljs-comment"># 使用git作为远程配置</span><br><span class="hljs-attr">spring.cloud.config.server.git.uri</span>=https://github.com/gagaducko/learning_demos<br><span class="hljs-attr">spring.cloud.config.server.git.username</span>=git username<br><span class="hljs-attr">spring.cloud.config.server.git.password</span>=git password<br><span class="hljs-attr">spring.cloud.config.server.git.default-label</span>=main<br><span class="hljs-attr">spring.cloud.config.server.git.search-paths</span>=config-demo<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;此处以本地为例：<br></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.application.name</span>=spring-cloud-config-server<br><span class="hljs-attr">server.port</span>=<span class="hljs-number">8080</span><br><br><span class="hljs-comment"># 用本地配置</span><br><span class="hljs-attr">spring.cloud.config.server.native.search-locations</span>=D:/code_gagaduck/learning_demos/config-demo<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;配置完成后，启动服务端，访问<a href="http://localhost:8080/%7Bapplication%7D/%7Bprofile%7D[/%7Blabel%7D]%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%8F%96%E5%88%B0%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E3%80%82">http://localhost:8080/{application}/{profile}[/{label}]，即可获取到配置信息。</a><br><br>&emsp;&emsp;如访问<a href="http://localhost:8080/test/properties%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%8F%96%E5%88%B0test.properties%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E3%80%82">http://localhost:8080/test/properties，即可获取到test.properties的配置信息。</a><br></p><h4 id="创建配置中心客户端使用配置"><a href="#创建配置中心客户端使用配置" class="headerlink" title="创建配置中心客户端使用配置"></a>创建配置中心客户端使用配置</h4><p>&emsp;&emsp;创建一个Spring Boot项目，引入依赖：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;在配置文件中做配置：<br></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.application.name</span>=spring-cloud-config-client<br><span class="hljs-attr">server.port</span>=<span class="hljs-number">8081</span><br><span class="hljs-attr">spring.config.import</span>=optional:configserver:<br><span class="hljs-attr">spring.cloud.config.uri</span>=http://localhost:<span class="hljs-number">8080</span><br><span class="hljs-attr">spring.cloud.config.name</span>=test<br><span class="hljs-attr">spring.cloud.config.profile</span>=properties<br><span class="hljs-comment">#spring.cloud.config.label=main</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;配置完成后，启动服务端，即可获取到配置信息。<br><br>&emsp;&emsp;需要注意的是，如果是git，是需要有label这些来定位的。另外，对于SpringBoot3.X来说，配置加载机制发生了变化，需要手动指定 spring.config.import 属性，以导入配置服务器的配置源。即，需要通过spring.config.import&#x3D;optional:configserver:来明确指出从配置服务器导入配置<br><br>&emsp;&emsp;当然，也可以加上如下方法来禁用对这一个的检查：<br></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.cloud.config.enabled</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;例如写个简单的controller检查一下：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;env&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String env;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;user.username&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;user.password&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/env&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String env() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;env in test is: &quot;</span> + env;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/username&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String username() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;username in test is: &quot;</span> + username;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/password&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String password() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;password in test is: &quot;</span> + password;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;调用<a href="http://localhost:8081/username%EF%BC%8C%E8%8E%B7%E5%BE%97%E5%9B%9E%E5%A4%8D%EF%BC%9A">http://localhost:8081/username，获得回复：</a><br></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">username <span class="hljs-keyword">in</span> test <span class="hljs-keyword">is</span>: gagaducko<br></code></pre></td></tr></table></figure><h4 id="在将Spring-Cloud-Config注册到注册中心的情况下，与其他服务进行通信"><a href="#在将Spring-Cloud-Config注册到注册中心的情况下，与其他服务进行通信" class="headerlink" title="在将Spring Cloud Config注册到注册中心的情况下，与其他服务进行通信"></a>在将Spring Cloud Config注册到注册中心的情况下，与其他服务进行通信</h4><p>&emsp;&emsp;将Spring Cloud Config注册到注册中心后，很显然的是，要发挥注册中心的作用，避免客户端程序直接与配置中心的服务端做交互，而要通过注册中心来做交互，也就是说要避免直接对spring cloud config的ip端口在客户端中进行配置，而要通过Eureka来进行实现。<br><br>&emsp;&emsp;参考上文，将server服务注册到注册中心中，启用为一个Eureka客户端，对于其他服务来说，引入eureka的client依赖，并配置客户端服务：<br></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 配置服务地址通过注册中心发现</span><br><span class="hljs-attr">spring.cloud.config.discovery.enabled</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">spring.cloud.config.discovery.service-id</span>=spring-cloud-config-server<br><span class="hljs-comment"># Eureka 注册中心地址</span><br><span class="hljs-attr">eureka.client.service-url.defaultZone</span>=http://localhost:<span class="hljs-number">8761</span>/eureka/<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这样，客户端在启动的时候，会通过注册中心去发现配置中心的服务示例，并获取配置信息。<br></p><h4 id="实现配置的自动刷新"><a href="#实现配置的自动刷新" class="headerlink" title="实现配置的自动刷新"></a>实现配置的自动刷新</h4><p>&emsp;&emsp;在Spring Cloud Config中，在项目启动的额时候加载配置内容。这一机制导致当配置内容修改后不会自动刷新的，因此，需要重启。这样是不太好的。可以通过@RefreshScope注解并结合actuator来实现配置的自动刷新。<br><br>&emsp;&emsp;需要做如下配置，首先要映入spring-boot-starter-actuator这个包：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;然后在配置文件中添加如下配置：<br></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">management<span class="hljs-selector-class">.endpoints</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.exposure</span>.include=*<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;在客户端程序中，通过如下方式来刷新配置：<br></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RefreshScope</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;例如：<br></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RestController</span><br><span class="hljs-variable">@RefreshScope</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这样，便可以通过调用这样一个接口来实现刷新配置了：<br></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8081</span><span class="hljs-regexp">/actuator/</span>refresh<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;调用后，配置内容便刷新了。<br><br>&emsp;&emsp;比如，将test.properties中的内容的username变为gagaducko111:<br></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">username <span class="hljs-keyword">in</span> test <span class="hljs-keyword">is</span>: gagaducko111<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;此外，也可通过增加监听器自动刷新，此处暂按不表，见网关实现动态路由的部分。<br></p><h3 id="Nacos-1"><a href="#Nacos-1" class="headerlink" title="Nacos"></a>Nacos</h3><p>&emsp;&emsp;Nacos除了是注册中心，也是配置中心。<br></p><h4 id="创建配置中心服务端"><a href="#创建配置中心服务端" class="headerlink" title="创建配置中心服务端"></a>创建配置中心服务端</h4><p>&emsp;&emsp;当Nacos安装Ok后，就可以作为配置中心进行使用。此处不表。<br></p><h4 id="创建配置中心客户端使用配置-1"><a href="#创建配置中心客户端使用配置-1" class="headerlink" title="创建配置中心客户端使用配置"></a>创建配置中心客户端使用配置</h4><p>&emsp;&emsp;对于需要使用Nacos配置中心的客户端来说，使用方式也是简单的。<br></p><h4 id="Nacos配置中心的Open-API"><a href="#Nacos配置中心的Open-API" class="headerlink" title="Nacos配置中心的Open API"></a>Nacos配置中心的Open API</h4><p>&emsp;&emsp;与Nacos注册中心相似，Nacos也提供一系列OpenAPI可供对配置中心进行操作，详见Nacos OpenAPI指南：<a href="https://nacos.io/zh-cn/docs/open-api.html">https://nacos.io/zh-cn/docs/open-api.html</a><br></p><h4 id="Nacos配置中心的编程方式"><a href="#Nacos配置中心的编程方式" class="headerlink" title="Nacos配置中心的编程方式"></a>Nacos配置中心的编程方式</h4><p>&emsp;&emsp;对于Nacos配置中心来说，也可以使用与注册中心相似的编程方式进行操作，详见<a href="https://github.com/gagaducko/springboot-nacosapi-example">https://github.com/gagaducko/springboot-nacosapi-example</a><br><br>&emsp;&emsp;此为采用编程方式对Nacos配置中心进行管理使用的一种方式。<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>注册中心</tag>
      
      <tag>配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(7)-微服务的权限方案</title>
    <link href="/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-6-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88/"/>
    <url>/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-6-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(6)—网关+Nacos的IP黑白名单限制</title>
    <link href="/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-4-%E2%80%94%E7%BD%91%E5%85%B3-Nacos%E7%9A%84IP%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E9%99%90%E5%88%B6/"/>
    <url>/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-4-%E2%80%94%E7%BD%91%E5%85%B3-Nacos%E7%9A%84IP%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>网关</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(5)—网关+Nacos+Sentinel的动态服务容错</title>
    <link href="/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-4-%E2%80%94%E7%BD%91%E5%85%B3-Nacos-Sentinel%E7%9A%84%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99/"/>
    <url>/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-4-%E2%80%94%E7%BD%91%E5%85%B3-Nacos-Sentinel%E7%9A%84%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>网关</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(4)—网关+Nacos的动态路由</title>
    <link href="/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-4-%E2%80%94%E7%BD%91%E5%85%B3-Nacos%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
    <url>/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-4-%E2%80%94%E7%BD%91%E5%85%B3-Nacos%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>网关</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(3)—微服务之间的相互调用</title>
    <link href="/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-3-%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/"/>
    <url>/2024/09/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-3-%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="微服务之间的相互调用"><a href="#微服务之间的相互调用" class="headerlink" title="微服务之间的相互调用"></a>微服务之间的相互调用</h2><p>&emsp;&emsp;服务多了，端口IP自然也就多了，用传统的带上IP和端口的HTTP进行Request甚至用更久远的UDP来进行通信，显然是不合理的。<br><br>&emsp;&emsp;尤其是对于微服务架构来说，很多功能需要调用多项服务才能完成，这时候，服务之间如何相互调用就成为了一个相当关键的问题，<br><br>&emsp;&emsp;首先，如果直接采用RestTemplate的方式进行服务之间的通信怎么样呢？<br><br>&emsp;&emsp;如下代码所示：<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">RestTemplate</span> <span class="hljs-title function_">getRestTemplate</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> <span class="hljs-title class_">RestTemplate</span> restTemplate;<br><br><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/test&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">String</span> url = <span class="hljs-string">&quot;http://localhost:8081/test&quot;</span>;<br>    <span class="hljs-title class_">String</span> result = restTemplate.<span class="hljs-title function_">getForObject</span>(url, <span class="hljs-title class_">String</span>.<span class="hljs-property">class</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这种方式虽然可行，但是代码显得有些冗余，而且如果需要调用多个服务，那么代码就会显得十分混乱，相当于是做了一个硬编码，IP地址等都有了，如果服务提供方的地址端口发生了变化，该怎么做呢？当然是手动修改代码，如果有多个实例呢？通过Nginx实现服务的负载均衡？显然是不美丽的？实例增加了呢？所以，问题是很多的。<br><br>&emsp;&emsp;因此，SpringCloud提供了一个叫做OpenFeign的组件，这个组件非常好用。<br><br>&emsp;&emsp;可以简化RestTemplate的调用，使得代码看起来更加简洁。更为重要的是，通过OpenFeign，可以解决很多的上述的问题，具体在后文中进行实践与分析。<br></p><h2 id="Restful风格的调用"><a href="#Restful风格的调用" class="headerlink" title="Restful风格的调用"></a>Restful风格的调用</h2><p>&emsp;&emsp;在了解OpenFeign之前，首先需要对于Restful风格的调用做了解。<br></p><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>&emsp;&emsp;OpenFeign是SpringCloud的一个组件。他的中心思想在于通过提供一种声明式、注解驱动的接口化服务调用方式，极大地简化了微服务架构中的RESTful API调用以及服务间通信的复杂性。它使得开发者可以聚焦于业务逻辑本身，如同调用本地方法一样便捷地调用远程服务，而不必深陷于HTTP请求细节的实现。<br></p><h3 id="OpenFeign的简单使用"><a href="#OpenFeign的简单使用" class="headerlink" title="OpenFeign的简单使用"></a>OpenFeign的简单使用</h3><p>&emsp;&emsp;首先，需要在pom.xml文件中引入OpenFeign的依赖，如下所示：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;然后，在启动类上需要添加上@EnableFeignClients注解，如下所示：<br></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableFeignClients</span><br>public class Application &#123;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(OrderApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;接着，创建一个Feign的客户端接口，通过@FeignClient做注解标记，如下所示：<br></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@FeignClient</span>(<span class="hljs-string">&quot;user-service&quot;</span>)<br>public interface UserFeignClient &#123;<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/user/&#123;id&#125;&quot;</span>)<br>    User <span class="hljs-built_in">getUserById</span>(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) Long id);<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;最后，在需要调用服务的地方，注入UserFeignClient，并调用其方法即可，如下所示：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserFeignClient userFeignClient;<br><br>    <span class="hljs-keyword">public</span> Order getOrderById(<span class="hljs-built_in">Long</span> id) &#123;<br>        <span class="hljs-comment">// 调用user-service的getUserById方法获取用户信息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;由此，便实现了对于该服务的一个调用。<br><br>&emsp;&emsp;值得一提的是，OpenFeign集成了Ribbon这样一个客户端负载均衡器，使得OpenFeign发起的HTTP请求可以自动地在多个服务实例之间进行一个负载均衡。如果想要自定义这样一个负载均衡策略，则需要引入ribbon再做进一步的操作。<br></p><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>&emsp;&emsp;对于微服务之间的消息通信来说，如果只是靠着OpenFeign这样的http客户端来实现微服务之间的通信，在很多地方是存在缺口的。<br><br>&emsp;&emsp;尤其是对于一些高并发、大量甚至海量数据的传递来说，是有问题的，OpenFeign进行服务之间的同步调用，而也需要将耗时长量大的消息放入消息队列做异步的处理也是相当重要的，因此，对于消息中间件的详细使用见后文内容。<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(2)—网关</title>
    <link href="/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-2-%E2%80%94%E7%BD%91%E5%85%B3/"/>
    <url>/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-2-%E2%80%94%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h2><p>&emsp;&emsp;网关是一项围绕微服务的重要技术。当微服务多了，端口这些东西自然也就多了，那么也就是说，微服务的入口就多了，这样是相当难以管理的，因此，API网关的出现从某种方面来讲，就是为了解决这个问题。<br><br>&emsp;&emsp;API网关内部封装了系统内部架构，为每个客户端提供了一个定制的API，由此实现成为一个微服务系统的唯一入口。<br><br>&emsp;&emsp;换言之，通过网关，所有的客户端和消费端都需要通过统一的网关来接入微服务系统，在网关层来处理所有非业务相关的东西。比如身份验证、监控、负载均衡、缓存、限流熔断、协议转换等等。<br><br>&emsp;&emsp;对于网关来说，要统筹后端服务，要分为数据平面和控制平面。数据平面主要是为了统一对外暴露后端服务的API等，而控制平面则是对后端服务做一个统一的管控和配置。<br><br>&emsp;&emsp;对于网关来说，最核心的功能就是路由功能。通过路由功能将微服务网关的请求转发到目标微服务，在实际上的微服务架构中，网关可以结合着注册中心的动态服务发现技术来发现后端服务，也可以借助配置中心的动态配置来变更动态路由。比如网关是localhost:38888，A服务的端口是3001，B服务端口是3002，对于使用来说，要使用A、B两个服务，便需要通过调用localhost:3001和3002来实现，这样显示是复杂的，尤其是服务多了之后，但是当在网关配置好路由后，便可以通过localhost:38888&#x2F;A访问A服务，通过localhost:38888&#x2F;B访问B服务，这样就会方便许多。<br><br>&emsp;&emsp;第二，对于网关来说，同样重要的还有负载均衡的功能，通过服务发现工具，通过如loadBalancer、轮询、IP地址哈希机制等方式来实现对于下游微服务的负载均衡。<br><br>&emsp;&emsp;此外，网关还可以和权限模块，与Redis、OAuth2等技术相结合，实现对于微服务系统的整体统一鉴权，API网关是统一管理安全性的绝佳场所，可以将认证的部分抽取此处，使得后续的服务，只需要关注业务逻辑而无需关注认证等安全逻辑。<br><br>&emsp;&emsp;网关还有一个作用，就是限流熔断，由于网关是统一的入口，对于一些由客户端访问次数和频率限制的服务来说，一些高并发请求下是要有限流需求的，网关要可以进行主动的熔断，来保护后端服务，确保前端用户的体验能够合理。<br><br>&emsp;&emsp;此外，网关还可以对请求进行一些过滤，来实现一个黑白名单的功能，作为一种终端管理的选择。<br><br>&emsp;&emsp;其他功能还有许多，于此不再一一叙述。可以说，网关对于微服务来说，是非常重要的一个组成部分。<br></p><h2 id="常见的网关"><a href="#常见的网关" class="headerlink" title="常见的网关"></a>常见的网关</h2><p>&emsp;&emsp;常见的网关有许多。<br><br>&emsp;&emsp;首先，Nginx作为一个反向代理服务器，自然是可以作为一种网关来使用的。于此不再赘述。<br><br>&emsp;&emsp;其次，对于Spring Cloud和Spring Cloud Alibaba这一套架构来说，Spring Cloud Gateway是一种相当重要的网关。后文进行详细阐述与实践。<br><br>&emsp;&emsp;在此以外，还有比如Zuul等网关，性能各异、功能也各异，于此不再过多赘述。<br></p><h2 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h2><p>&emsp;&emsp;Spring Cloud Gateway 是由WebFlux + Netty + Reactor所实现的一种响应式的 API 网关。<br><br>&emsp;&emsp;就其在Spring Cloud的定位来说，是为了取代如Netflix Zuul这样的老网关作为一个新一代的网关来使用的。<br><br>&emsp;&emsp;比起上一代的网关，Spring Cloud Gateway的功能更强大、性能更强大、可拓展的点也更多。<br><br>&emsp;&emsp;于后文介绍一个Gateway最基本的使用。并在这个基础上，对于动态路由、动态服务容错、IP黑白名单机制、鉴权等方面做一个详细的实践及阐述。<br></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;对于微服务来说，网关几乎是不可或缺，必不可少的，通过网关，能够实现微服务业务与技术逻辑相解耦的一个重中之重。<br><br>&emsp;&emsp;如果用较为简洁的语言来阐述网关，几乎就等同于路由转发+过滤器。路由转发就是其数据平面的工作而过滤器便是其控制平面的工作。<br><br>&emsp;&emsp;由此，重要性，不言而喻。<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务，网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—基础知识</title>
    <link href="/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>&emsp;&emsp;首先，要知道什么是微服务，得理解软件架构的演变。<br></p><h2 id="早期单体架构"><a href="#早期单体架构" class="headerlink" title="早期单体架构"></a>早期单体架构</h2><p>&emsp;&emsp;早期的软件，所有的功能都写在一起，整个软件是一个单一的整体，这就是单体架构。<br><br>&emsp;&emsp;单体架构随着软件功能的增加，不可避免的就会就会越来越复杂，存在着许多的缺点<br></p><ul><li>所有功能耦合在一起，互相影响，最终难以管理。</li><li>哪怕只修改一行代码，整个软件就要重新构建和部署，成本非常高。</li><li>因为软件做成了一个整体，不可能每个功能单独开发和测试，只能整体开发和测试，导致必须采用瀑布式的开发模型。</li></ul><p>&emsp;&emsp;简而言之，单体架构的大型软件，不仅开发速度慢，而且会形成难以维护和升级的复杂代码，成为程序员的沉重负担。<br></p><h2 id="面向服务架构（SOA）"><a href="#面向服务架构（SOA）" class="headerlink" title="面向服务架构（SOA）"></a>面向服务架构（SOA）</h2><p>&emsp;&emsp;随之而来的，就是为了解决这些问题，人们提出来，要打破软件代码的耦合，将单体架构的软件拆分成一个个独立的功能单元。<br><br>&emsp;&emsp;大概在二十多年前，随着互联网的出现，功能单元，可以通过远程“服务”的方式来提供，以此诞生出了面向服务架构（service-oriented architecture，简称 SOA）。<br><br>&emsp;&emsp;什么是服务（service）呢？service 就是后台不间断运行、提供某种功能的一个程序。最常见的服务就是 Web 服务，通过80端口向外界提供网页访问。<br><br>&emsp;&emsp;而SOA就是把一个大型的单体程序，拆分成一个个独立服务，也就是说较小的程序，每个程序都是一个独立的功能单元，承担着不同的功能，服务之间通过通信协议连在一起。<br><br>&emsp;&emsp;于此，这种SOA的优点就展现出来了：<br></p><ul><li>每种服务功能单一，相当于一个小型软件，便于开发和测试。</li><li>各个服务独立运行，简化了架构，提高了可靠性。</li><li>鼓励和支持代码重用，同一个服务可以用于多种目的。</li><li>不同服务可以单独开发和部署，便于升级。</li><li>扩展性好，可以容易地加机器、加功能，承受高负载。</li><li>不容易出现单点故障。即使一个服务失败了，不会影响到其他服务。</li></ul><p>&emsp;&emsp;跟单体架构不一样，面向服务架构是语言不敏感的，不同服务可以使用不同的语言和工具开发，可能需要部署在不同的系统和环境。<br><br>&emsp;&emsp;当然这意味着，面向服务架构默认运行在不同服务器上，每台服务器提供一种服务，多台服务器共同组成一个完整的网络应用。<br></p><h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><p>&emsp;&emsp;在有了SOA之后，随着时代的发展，还需要了解这个部署方式的变化。<br><br>&emsp;&emsp;也就是虚拟化技术的发展。虚拟化技术至今已经走过了三个时代，没有容器化技术的演进就没有docker技术的诞生。<br><br>&emsp;&emsp;首先，是物理机时代，一个物理机，一个os，上面可能会跑很多个程序<br><br>&emsp;&emsp;进一步的，是虚拟机时代，一台物理机器安装多个虚拟机，一个虚拟机跑多个程序。<br><br>&emsp;&emsp;再进一步的，就是容器化的时代，一台物理机安装多个容器实例，一个容器跑多个程序。<br><br>&emsp;&emsp;容器化技术的一大优点就是：开发人员编写代码，本地环境是好的，但是部署到测试环境中，坏了，全是bug，环境不同。容器化技术，就是解决了该问题，将软件程序和运行的基础环境分开，开发人员编码完成后，将程序打包到一个容器镜像中去，镜像中详列出所依赖的环境，不同的容器中运行标准化的镜像，从而从根本上解决了环境不一致的问题。可移植性好，占地小，共享bin和lib<br><br>&emsp;&emsp;2014年，docker的出现，改变了软件开发的面貌，它让程序运行在容器中，每个容器可以分别设定运行环境，只需要占用很少的系统资源就可以使用。<br><br>&emsp;&emsp;显而易见，可以用容器来实现”面向服务架构”，每个服务不再占用一台服务器，而是占用一个容器。<br><br>&emsp;&emsp;这样就不需要多台服务器了，最简单的情况下，本机运行多个容器，只用一台服务器就实现了面向服务架构，这在以前是做不到的。这种实现方式就叫做微服务。<br><br>&emsp;&emsp;所以，微服务到底是什么呢？<br><br>&emsp;&emsp;简单说，微服务就是采用容器技术的面向服务架构。它依然使用”服务”作为功能单元，但是变成了轻量级实现，不需要新增服务器，只需要新建容器（一个进程），所以才叫做”微服务”。<br><br>&emsp;&emsp;微服务架构是一种软件架构风格，其中应用程序以一组小型、独立的服务构建，每个服务运行在自己的进程中，并使用轻量级通信机制进行通信。<br><br>&emsp;&emsp;一个微服务就是一个独立的进程。 这个进程可以运行在本机，也可以运行在别的服务器，或者在云端（比如云服务和云函数 FaaS）。<br><br>&emsp;&emsp;它的特点与面向服务架构是一样的，但因为更轻量级，所以功能的解耦和服务化可以做得更彻底。而且，它可以标准化，同样的容器不管在哪里运行，结果都是一样的，所以市场上有很多 SaaS 产品，提供标准化的微服务。<br><br>&emsp;&emsp;正是由于微服务这些突出的优点，这些年才会变得如此流行。它和容器技术、云服务等一起，一定会在未来的软件开发中，扮演越来越重要的角色。<br></p><h2 id="微服务的技术栈"><a href="#微服务的技术栈" class="headerlink" title="微服务的技术栈"></a>微服务的技术栈</h2><h4 id="docker-k8s"><a href="#docker-k8s" class="headerlink" title="docker &amp;&amp; k8s"></a>docker &amp;&amp; k8s</h4><p>&emsp;&emsp;首先，微服务的核心就是容器化技术，每一个微服务都需要以docker或者其他容器的方式进行使用，每一个服务都在一个独立的容器中。<br><br>&emsp;&emsp;2010年一位年轻小伙子在美国旧金山成立了一家名叫【dotCloud】的公司， 开发了 Docker的核心技术，从此开启了容器技术的时代。<br><br>&emsp;&emsp;后面 dotCloud 公司将自己的容器技术进行了简化和标准化，取名为 Docker，就是大家熟悉的鲸鱼 logo。<br><br>&emsp;&emsp;尽管Docker为容器化的应用程序提供了开放标准，但随着容器越来越多出现了一系列新问题：<br></p><ul><li>如何协调和调度这些容器</li><li>如何在升级应用程序的时候不会中断服务</li><li>如何监视应用程序的运行状况</li><li>如何批量重新启动容器内的程序</li></ul><p>&emsp;&emsp;要解决这些问题，就需要容器编排技术，可以将众多的极其抽象，对外呈现出一台超级大机器，比如现在业界流行的k8s。<br><br>&emsp;&emsp;在业务发展初期只有几个微服务，这时用 Docker 就足够了，但随着业务规模逐渐扩大，容器越来越多，运维人员的工作越来越复杂，这个时候就需要编排系统解救运维人员。<br><br>&emsp;&emsp;换言之，在微服务架构中，使用Docker或其他容器打包发布应用，使用kubernetes扩展、运行、监控应用。<br><br>&emsp;&emsp;此外，没有k8s也可以使用docker，k8s非常复杂，在业务比较简单的时候可以放弃使用k8s<br><br>&emsp;&emsp;然而，需要注意的是，k8s是一个容器编排器，没有容器，没法编排。没有docker这类容器，就无法使用k8s，k8s主要还是和docker这些容器进行搭配，当然，其他容器也是可以的，比如Containerd <br></p><h4 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h4><p>&emsp;&emsp;一个微服务架构的重中之重，除了docker就是服务注册与发现。<br><br>&emsp;&emsp;微服务之间才能相互调用完成整体的业务功能，如何在众多的微服务中找到正确的目标服务地址呢，如果服务的IP或者端口变了，那是否就需要对庞大的微服务们进行修改呢，这就需要服务发现的功能。<br><br>&emsp;&emsp;要发现服务，自然首先要注册服务，最常用的做法就是在服务提供者启动的时候就将地址上报给服务注册中心，这就是服务注册。<br><br>&emsp;&emsp;服务调用方通过订阅服务变更的通知，动态的接收到服务注册中心所推送的服务地址列表，想找哪个服务直接发送就可以了。<br><br>&emsp;&emsp;现在Spring Cloud和Spring Cloud Alibaba常用的服务注册与发现工作包括eureka和nacos等。<br></p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>&emsp;&emsp;在微服务架构中，一个微服务可能有很多个实例，每个实例的配置可能都不一样，比如数据库连接地址，数据库用户名密码等，如果每个实例都手动修改，那无疑是非常麻烦的，所以就需要配置管理。<br><br>&emsp;&emsp;配置管理就是将配置信息集中管理，每个实例启动的时候从配置管理中获取配置信息，这样就可以保证每个实例的配置信息都是一致的。<br><br>&emsp;&emsp;配置管理可以使用Spring Cloud Config或者Spring Cloud Alibaba Nacos等。<br></p><h4 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h4><p>&emsp;&emsp;在微服务架构中，一个服务可能会调用多个其他服务，如果其中一个服务出现故障，那么整个服务就会崩溃<br><br>&emsp;&emsp;任何服务都不能保证100%不出问题，生产环境复杂多变，服务运行过程中不可避免的发生各种故障（宕机、过载等等），工程师能够做的是在故障发生时尽可能降低影响范围、尽快恢复正常服务。<br><br>&emsp;&emsp;程序员为了避免被祭天，需要引入「熔断、隔离、限流和降级、超时机制」等「服务容错」的机制来保证服务持续可用性。<br><br>&emsp;&emsp;服务容错可以通过熔断、降级、限流等方式来实现，常用的工具有Hystrix、Sentinel等。<br></p><h4 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h4><p>&emsp;&emsp;在微服务架构中，服务之间的调用纷繁复杂，有些服务的敏感数据存在安全问题，「服务安全」就是对敏感服务采用安全鉴权机制，对服务的访问需要进行相应的身份验证和授权，防止数据泄露的风险，安全是一个长久的话题，在微服务中也有很多工作要做。<br><br>&emsp;&emsp;服务安全可以通过OAuth2、JWT等方式来实现，常用的工具有Spring Security、OAuth2等。<br></p><h4 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h4><p>&emsp;&emsp;在微服务架构中，服务之间的调用纷繁复杂，如果每个服务都暴露自己的API接口，那么调用方就需要知道每个服务的API接口，这无疑是非常麻烦的，所以就需要一个统一的入口，这就是API网关。<br><br>&emsp;&emsp;API网关就是将所有的API接口都集中在一个地方，调用方只需要调用API网关，API网关会根据请求的路径和参数，将请求转发到相应的服务，API网关还可以配合其他工具实现负载均衡、限流、鉴权、动态路由等功能。<br></p><h4 id="服务追踪"><a href="#服务追踪" class="headerlink" title="服务追踪"></a>服务追踪</h4><p>&emsp;&emsp;在微服务架构中，服务之间的调用纷繁复杂，如果出现故障，如何快速定位是哪个服务出现了问题呢？那么就需要定位问题，这就需要服务追踪。<br><br>&emsp;&emsp;服务追踪就是将每个请求的调用链路记录下来，这样就可以根据请求的调用链路来定位问题，常用的工具有Zipkin、SkyWalking等。<br></p><h4 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h4><p>&emsp;&emsp;此外，服务的运行过程难免需要对其性能等内容进行监控，因此，监控也是必不可少的。<br></p><h2 id="微服务的发展"><a href="#微服务的发展" class="headerlink" title="微服务的发展"></a>微服务的发展</h2><p>&emsp;&emsp;2011年，微服务的概念由Netflix等企业提出，他们需要一种更灵活、独立的服务模式，以满足大规模互联网应用的扩展性需求。与SOA相比，微服务是去中心化的，服务更小、独立，且通过HTTP、消息队列等协议通信。<br><br>&emsp;&emsp;2012-2015年：Netflix开源了一系列微服务相关的工具，这些工具构成了微服务生态系统的基础组件。<br></p><ul><li>Eureka（2012）：Netflix推出的服务注册和发现组件，允许微服务在启动时注册，并通过Eureka客户端进行相互发现。</li><li>Hystrix（2012）：Netflix推出的熔断器，用于处理服务调用失败和网络超时。</li><li>Ribbon（2012）：用于负载均衡的组件。</li><li>etc.</li></ul><p>&emsp;&emsp;此外，2014年，Spring Cloud项目正式发布，整合Netflix的微服务工具，简化了Java开发者构建微服务的工作。<br><br>&emsp;&emsp;到2015年，Spring Cloud成为了微服务架构中流行的框架，提供着一整套解决方案，推动了微服务架构的大规模应用。<br><br>&emsp;&emsp;2017年，随着阿里巴巴开源了Nacos，这一款集服务发现、配置管理于一体的组件，替代了eureka的部分功能。Nacos能够提供更加灵活的配置管理和服务注册功能，并且支持AP和CP（即一致性和可用性）的权衡，逐渐在国内流行起来，替代了部分Eureka的使用场景。其他各型组件也是类似情况，替代方案逐渐增加。<br><br>&emsp;&emsp;2014年，Google开源了Kubernetes（简称K8s），这是一个容器编排工具，可以自动化管理容器化应用的部署、伸缩和运维。Kubernetes逐渐成为云原生应用的核心平台。<br><br>&emsp;&emsp;2017年，服务网格（Service Mesh）架构开始流行，Istio成为其代表工具。服务网格将服务间的通信逻辑（如负载均衡、熔断、流量控制等）从应用中剥离，交由一个独立的基础设施层管理。Istio使用Envoy作为数据平面，负责流量管理，而Istio本身作为控制平面。<br><br>&emsp;&emsp;2020年之后，Kubernetes和服务网格技术结合，成为了微服务架构的主流模式。通过Kubernetes进行容器编排，服务网格则负责微服务之间的通信、流量管理、监控和安全。<br><br>&emsp;&emsp;通过Helm这一Kubernetes的包管理工具，简化了应用的部署。<br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;总的来说呢，微服务架构现在正在变得更加成熟和普及，虽然随着Kubernetes + Istio的流行，传统的微服务框架如Spring Cloud逐渐被替代，但微服务架构的核心思想仍然存在，并且随着技术的不断进步，微服务架构将会变得更加灵活和高效。<br><br>&emsp;&emsp;而原先的框架如Spring Cloud和Spring Cloud Alibaba，其实也有一定的优势，模块丰富，技术成熟，方案完整，在许多场景下也有相当适用的一面。<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—通过nginx对UDP做负载均衡</title>
    <link href="/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E9%80%9A%E8%BF%87nginx%E5%AF%B9UDP%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E9%80%9A%E8%BF%87nginx%E5%AF%B9UDP%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在某些场合下，大量的请求对于单个实例来说是很难承受的，有可能会导致服务器宕机。<br><br>&emsp;&emsp;因此，所谓负载均衡，就是要把大量的请求按照指定的方式均衡分配给集群中的每台服务器，从而避免这种情况。<br><br>&emsp;&emsp;做负载的方式有许多，此处针对UDP，通过nginx做负载均衡。<br><br>&emsp;&emsp;实现负载均衡前，首先需要实现反向代理，也就是说，请求到某个宇明的时候，该请求默认是被nginx接收到的，然后nginx根据配置，做解析，把特定的请求转发到对应的服务器上去。如下述代码为nginx.conf的一部分。<br></p><figure class="highlight nginx"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-section">upstream</span> udp_servers &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8081</span>;  <span class="hljs-comment"># 第一个UDP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8082</span>;  <span class="hljs-comment"># 第二个UDP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8083</span>;  <span class="hljs-comment"># 第三个UDP程序实例的地址和端口</span><br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span> udp;<br>        <span class="hljs-attribute">proxy_pass</span> udp_servers;<br>        <span class="hljs-attribute">proxy_responses</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码是用于nginx服务器配置的，定义了一个UDP流量的负载均衡设置。<br><br>&emsp;&emsp;stream{}这一行表示开始定义了一个流模块的配置块，nginx的流模块可以用于处理TCP和UDP流量。<br><br>&emsp;&emsp;upstream udp_servers {}：这一行定义了一个名为udp_servers的上游服务器组。这个组将包含多个UDP服务器实例，用于处理负载均衡。其中包含的就是可以负载过去的实例对象。<br><br>&emsp;&emsp;server 192.168.186.1:8081;：这是定义在udp_servers组中的第一个服务器实例，其IP地址为192.168.186.1，端口为8081。这表示UDP流量可以被发送到这个地址和端口。<br><br>&emsp;&emsp;另外两个同理。<br><br>&emsp;&emsp;server {}：这一行开始定义一个服务器配置块，它将监听特定的端口，并将流量代理到上游服务器。<br><br>&emsp;&emsp;listen 8080 udp;：这一行指定Nginx服务器将监听UDP协议的8080端口。任何到达这个端口的UDP数据包都将被Nginx处理。<br><br>&emsp;&emsp;proxy_pass udp_servers;：这一行指定了将流量代理到之前定义的udp_servers上游服务器组。这意味着Nginx将根据负载均衡算法将UDP数据包发送到组中的服务器。<br><br>&emsp;&emsp;proxy_responses 1;：这一行配置了代理响应的数量。在这里，它被设置为1，意味着Nginx在接收到来自上游服务器的第一个响应后，就会停止处理并返回给客户端。这在某些UDP协议中很有用，比如DNS查询。<br><br>&emsp;&emsp;这样，监听8080端口的UDP流量，就会被分发到三个不同的UDP服务器实例上。<br><br>&emsp;&emsp;HTTP与TCP是类似的。<br><br>&emsp;&emsp;如下为一个包含8080端口的UDP、8081端口的UDP和8080端口的HTTP负载均衡的nginx.conf的示例，在这个配置中，UDP和HTTP（包块还有websocket）流量都配置在一个端口上，但是NGINX可以根据类型正确的分发它们。<br></p><figure class="highlight nginx"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><br><span class="hljs-comment"># HTTP 负载均衡配置</span><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">upstream</span> http_servers &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8082</span>;  <span class="hljs-comment"># 第一个HTTP实例</span><br>        <span class="hljs-comment"># 更多的HTTP服务实例</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8083</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8084</span>;<br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;  <span class="hljs-comment"># HTTP 监听端口</span><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://http_servers;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;  <span class="hljs-comment"># 确保将正确的 Host 头部传递给上游服务器</span><br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br><br>    <span class="hljs-comment"># WebSocket 专用头部设置</span><br>            <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;  <span class="hljs-comment"># 支持 WebSocket 的升级机制</span><br>            <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br>            <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">60s</span>;  <span class="hljs-comment"># 允许 WebSocket 连接保持 60s</span><br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># UDP 负载均衡配置</span><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-section">upstream</span> udp_servers1 &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8082</span>;  <span class="hljs-comment"># 第一个UDP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8083</span>;  <span class="hljs-comment"># 第二个UDP程序实例的地址和端口</span><br>        <span class="hljs-comment"># 添加更多UDP服务器实例</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8084</span>;  <span class="hljs-comment"># 第三个UDP程序实例的地址和端口</span><br>    &#125;<br><br>    <span class="hljs-section">upstream</span> udp_servers2 &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8085</span>;  <span class="hljs-comment"># 第一个UDP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8086</span>;  <span class="hljs-comment"># 第二个UDP程序实例的地址和端口</span><br>        <span class="hljs-comment"># 添加更多UDP服务器实例</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8087</span>;  <span class="hljs-comment"># 第三个UDP程序实例的地址和端口</span><br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span> udp;<br>        <span class="hljs-attribute">proxy_pass</span> udp_servers1;<br>        <span class="hljs-attribute">proxy_responses</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8081</span> udp;<br>        <span class="hljs-attribute">proxy_pass</span> udp_servers2;<br>        <span class="hljs-attribute">proxy_responses</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;  <span class="hljs-comment"># 默认配置</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;值得注意的是，为了确保nginx代理服务器能够正确的处理websocket连接，需要有一些专门的设置，如上所示。其中：<br><br>&emsp;&emsp;proxy_http_version 1.1;WebSocket 协议需要使用 HTTP&#x2F;1.1 版本。这是因为 WebSocket 连接在建立时，会使用 HTTP 升级机制从标准的 HTTP 或 HTTPS 请求升级到 WebSocket 连接。HTTP&#x2F;1.1 支持这种升级机制。<br><br>&emsp;&emsp;proxy_set_header Upgrade $http_upgrade;这个头部告诉代理服务器，客户端想要升级连接到 WebSocket 协议。$http_upgrade 是一个 Nginx 变量，它包含了客户端请求中的 Upgrade 头部的值。如果客户端请求中包含 Upgrade: websocket，则此变量值为 websocket，否则为空。<br><br>&emsp;&emsp;proxy_set_header Connection “upgrade”;当客户端请求升级到 WebSocket 连接时，它还会发送一个 Connection: Upgrade 头部。这个设置确保了代理服务器将这个头部转发给上游服务器，表示客户端想要升级协议。<br><br>&emsp;&emsp;proxy_read_timeout 60s;WebSocket 连接一旦建立，就会保持开放状态直到客户端或服务器决定关闭。默认情况下，Nginx 的 proxy_read_timeout 设置可能比较短，这可能会导致 WebSocket 连接在没有数据传输时被关闭。将此值设置得更高（如 60 秒），可以确保在没有数据传输的情况下连接不会超时。<br><br>&emsp;&emsp;proxy_set_header X-Forwarded-Proto $scheme;这个头部用于告诉上游服务器，原始请求使用的是 HTTP 还是 HTTPS 协议。这对于那些需要知道客户端原始连接协议的上游服务器来说很重要。$scheme 变量包含了请求的协议（http 或 https）。<br><br>&emsp;&emsp;靠着这一系列的配置，确保nginx能够正确处理websocket的升级握手并且在握手成功后维持连接，从而使得websocket的连接可以正常工作。<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UDP</tag>
      
      <tag>Nginx</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年8月总结</title>
    <link href="/2024/09/02/2024%E5%B9%B48%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <url>/2024/09/02/2024%E5%B9%B48%E6%9C%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;八月过得倒是也快。<br><br>&emsp;&emsp;月初送走了联培的学长学姐，细细想来，多少也算一年的苦友了，倒是有些不舍。<br><br>&emsp;&emsp;现在所谓的学硕是越发少了，而专硕专博的名额反倒是越发多了，一年前，有朋友一直跟我说联培不好，去了联培基地就是当牛马，现在看来，倒也不尽然，若是向下联培，自然就如史湘云入寒窑，这辈子算是有了；但若是向上联培，反倒是刘姥姥进大观园，感叹以前过得是什么苦日子了，也不失为一件美事。尤其是当联培的学长发来其联培的幸福生活的时候，从厂子里回来，弯了一天的腰可算是断了。<br><br>&emsp;&emsp;但与此同时，随着他们的离开，也惊觉八月一整个月都要作为绝对的驻厂主力成员在这依托答辩的横向上来承受痛苦了。<br><br>&emsp;&emsp;正因如此，痛苦，是这个月的主基调。<br><br>&emsp;&emsp;厂子里的氛围是越发压抑了，搞什么敏捷开发，不断加需求变需求，驻厂就驻厂，还被各式各样的人指指点点，每天13小时的工作时长，在监工注视下的高度紧张，做了非常多的活儿，每天都非常的累，看板上的工作反而是越发的多了，真好，这半年来的惨痛生活真是一种另类的芝麻开花了，一天过得比一天惨了。<br><br>&emsp;&emsp;此间有什么细节呢？老实说，不太回忆的起来了，只有痛苦的感觉而没有痛苦的记忆了，也算是一种自我保护机制吧。看着日历，是越发盼望着开学了，这其实是不准确的，盼望着脱离苦海吧。但是，这苦海的源头到底在哪里呢？脱离了这个苦海难道就没有下一个苦海了吗？不好说，也难说。但是难说就应该不说吗？进一步的，难做就应该不做吗？<br><br>&emsp;&emsp;最近看见了童润中的事情，想起了一个不咋熟但是久闻大名的同学。食堂的饭菜难吃了，投诉；买东西缺斤少两了，投诉；看到有恶劣行为，举报。凡此种种，不胜其数，凡是恶事、坏事，容不得一点沙子。虽然听起来正气到很离谱，但是很多时候仔细想想，社会的进步就是靠着这类人一点点往前推动的。这些人是在为众人抱柴，越多自然是越好。<br><br>&emsp;&emsp;我或许没有这么刚的勇气，但这不应该是我退缩的原因，要行动起来，想一些更好的办法，做一些更好的事情。<br><br>&emsp;&emsp;下个月最大的盼望就是能尽快脱离苦海，有充足的时间，没有过于emo的情绪，这是行动的保障，比起时常感慨于自己的牛马生活，或许思考更加的重要，立下一个小小的flag，九月开始，要重新拾起读书思考的老习惯。<br></p>]]></content>
    
    
    <categories>
      
      <category>每月总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2024年</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年年中总结</title>
    <link href="/2024/07/31/2024%E5%B9%B4%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/31/2024%E5%B9%B4%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;想要记录一些东西，倒也不是一时半刻了，只不过，过往时日，话到笔尖，总归是落不下去。<br><br>&emsp;&emsp;去年这个时间点，正值大三结束，待入毕业季，众多选择的十字路口让我陷入了无尽的纠结与焦虑之中。那时候的我，完全没有想象到自己一年后的精神状态与生活状态，会是如此的糟糕。越来越差的记忆力，越来越差的心情，越来越差的身体状况，让我开始怀疑人生，怀疑自己。<br><br>&emsp;&emsp;一年前推免的时候，发生了什么呢？记忆已然模糊了。但那时的心情，却还暂存在胸口，焦虑、迷茫、不安，种种情绪交织在一起，让我无法入睡。即便是有熟悉的朋友向我三番五次强调将要做下的选择，会是何等的光景，我也还是在这复杂的情绪下，迈出了阶段性的一步。<br><br>&emsp;&emsp;或许朋友说的很对。<br><br>&emsp;&emsp;起码，在当下的关头，是对的。<br><br>&emsp;&emsp;这一年来，有一句话，一直刻在我的心头：“选择比努力更重要。”<br><br>&emsp;&emsp;是啊，选择比努力更重要。但是，当选择已经做下，又该如何去面对呢？<br><br>&emsp;&emsp;最近心情一直很差，做许多事情都抬不起兴趣，甚至有些消极。有坏处，但也有好处。心情低落的时候是做不下去主线的，但心情低落的时候，却可以在不断的发呆中审视自己，做一下无关生活主线的事情。近日更是翻到了实验室几年前毕业了的学长写的博客，感慨其长期坚持的毅力同时，却又想起了写学期总结时完全想不起来发生了什么的无奈。<br><br>&emsp;&emsp;既然不想思考了，那便落笔记录一下流水账吧，或许以后会用到。<br><br>&emsp;&emsp;这样想着，便在低落的状态下，开始记录了。<br><br>&emsp;&emsp;第一篇随笔，就借着学期总结，回忆一下过半的2024年吧。<br><br>&emsp;&emsp;一月，开年就是极度不顺利的一个月。实验室的一个横向项目，需要驻厂，用通俗易懂的说法就是，需要学生去厂子里面全天开发。乍一听似乎并不是什么大事儿，毕竟在哪儿干活不是干活呢？不过，这件事情的离谱程度已经远远超出了许多人的想象，容我在接下来的内容中再叙述。对于研一的学长学姐来说，靠着课程，有着充足的理由可以抽身于此，而这份苦差，自然而然就落到了大四，或者说准研一的头上。<br><br>&emsp;&emsp;其实，从去年的12月下旬，这个横向的驻厂开发工作便开始了，如果用一句话来概述：在一个压抑到窒息的环境下，每周三天，蜗居一角，用落后的开发环境，通过“记事本”写代码开发，浪费本就不多的生命。<br><br>&emsp;&emsp;其间细节，出于各种原因，倒也不可多言。但是，保密，我能理解，需要人驻厂，我也能理解；只是，我不能理解，相当恶劣的物理环境，相当抽象的开发环境，相当混乱的项目管理。开始痛苦，过程痛苦，预计结尾更加痛苦；配环境痛苦，开发痛苦，同步痛苦，连吃饭都很痛苦。只能说驻厂真的是非常非常非常痛苦的一个环节，而痛苦的主要原因却并非是能力或者复杂的业务造成的。而且，这段时间的驻厂，干的是什么活呢？物理搬运服务器，物理搬运主机，在离线环境下配置“真·干干净净”的服务器……<br><br>&emsp;&emsp;一月的结尾和二月的开头，是本科最后的寒假。谈不上好，有小一半的时间都在医院里面了，但是在家里总归是好的，和家人在一起，缓和了很大一部分的负面情绪。<br><br>&emsp;&emsp;二月中，开学了，这个学期，开始预先上了两门研究生的课程。选这两门课的目的并不单纯，只是为了也有理由每周可以少去两天横向所在的厂子。自然，对于能否取得这两门课的好成绩，又或者说，去不去上这两门课，倒是都也不重要了，<br><br>&emsp;&emsp;不过，开学了，自然也就意味着上文提到的横向项目，又要开始驻厂了。靠着这两门课，加上研一缓和了很多的课程压力。研一的学长学姐们一周也需要去驻厂个1天半天的了，虽然不多，却是让我每周可以少浪费一天的生命，只需要去两天了。<br><br>&emsp;&emsp;对于身心的折磨，自然，也就重启了。<br><br>&emsp;&emsp;三月，虽然才刚开学，但是对于所上的两门课，已经进入了三天打鱼两天晒网的阶段了。原因很简单，横向的开发进入一个加速阶段了，离谱的甲方开始刷纯在感了。去驻一天的厂，需要花两天的时间来消耗负面情绪和身体的疲惫，想要做什么？太困难了。唯一值得庆幸的是，和我一块去的人，还能聊聊天，总不至于完全陷入自我封闭的状态。<br><br>&emsp;&emsp;四月，情况坏起来了，每周三和每周五，当去到横向的厂子里，便发现怎么这么离谱，全是活？周三去发现联调的进度和上周五相差不大，周五发现和周三相差不大，每天都在火急火燎的干活，精神进入了一个高度紧张的状态。<br><br>&emsp;&emsp;五月，虽然还是要在厂子里面驻厂，但总归是要赶一下毕业论文了。从某个角度上来讲，或许该“感谢”一下这个横向，毕竟毕设的课题来源于此。但是，整个五月，反而是最光怪陆离的。<br><br>&emsp;&emsp;一方面，五月，在厂子里发生了非常多不愉快的事情，同样是出于保密原因，就不多留述了，打一个简单的比方，每天都会有人来看你有没有好好吃💩，没吃或者吃少了，就想方设法喂你一口，真好，怕饿着了；另一方面，在校内写毕设的时间是真短啊，人的精力是有限的，当一件事情占用了你大部分精力的时候，另一件事情就很难兼顾了。不可能说我这段时间加把劲儿，就能多干好多事情，一段时间的精力投入是有上限的，这决定了这段时间能干成干好的事情。<br><br>&emsp;&emsp;五月还必须得感谢一个工程能力很强的学长，靠着他，这个横向才没有挂掉。与此同时，五月，我才从这个横向其他单位的同事那里知道，原来其他的学长，一周其实只轮着去驻厂半天，而且，一驻厂就睡大觉，突然间就明白，为什么每周三和周五工作堆积的这么多了。<br><br>&emsp;&emsp;不过，我并没有觉得这有什么不好，正如上面我所提到的，他们身上被插上的其他事情也很多，精力总归是有限的，在某些事情上摆烂一点，是好事儿。<br><br>&emsp;&emsp;六月，是毕业月。与濒临崩溃的精神状态相衬的是，六月毕业季里校园里弥漫着的毕业气息。本科生活总归是要结束了，这段时间我想了很多，回忆了许多，突然间熟悉的生活就要不再了，对未来却又没有什么期待，进入了一种浑浑噩噩的状态。<br><br>&emsp;&emsp;六月底，我是扛不住了，精神离崩溃只有一步之遥，终于，我在毕业典礼后的一周（七月一号），请假开始了我短暂的两周毕业旅行。头半周在江浙补了许多疫情几年想去却没找到机会的地方。后面则是与好几个班级的朋友去了内蒙古，草原、沙漠，突然间觉得生命好美好，手头的刀又放下了，尽管知道这就像一个短暂的美梦，醒来后还是得面对那个令我痛苦不堪了半年多的横向，我也必须承认，短短两周给我带来的休息效果是非常棒的，生活又有了一点期待，虽然不多。<br><br>&emsp;&emsp;七月开始，是这个牛马横向项目最艰难的时期，甲方开始疯狂催促了，而整个项目还处在一个烂尾的状态。我在六月三十号前，花了小一周时间，把工作和两个学长学姐对接过了，但是当我七月十四号回来的时候，看到的却是几乎完全没有进展的工作情况。<br><br>&emsp;&emsp;我能理解他们，真的。对于一个ToL（To Leader）项目，责任心越重，就会越痛苦，横向做的再好，投入再多的时间，对于学生来说，只是负担加重了，对于权责关系的“权”来说，几乎没有什么帮助。<br><br>&emsp;&emsp;学长们躺平，说明他们不光是意识到了这一点，更是在践行这一点了。在这方面，是值得学习的，躺平，学会踢皮球，“我压力也未尝不大”。<br><br>&emsp;&emsp;不过，单就这个项目来说，总归是要有人做的，七月的后面两周，我开始了大加班。除了驻厂难以开发，白天写晚上写，周内写周末写，总归是很大程度的推进了这个项目，缓和了很大的压力。很难说这个折磨人的横向有没有提升自己的能力，或许是有的，只不过我认为与其付出相较而言，完全不等价。<br><br>&emsp;&emsp;也是这两日，联培的学长们就要走了，实验室长一届的学长学姐一下就只剩下三个了，一时之间，有些恍惚，原来已经一年了啊……<br><br>&emsp;&emsp;半年的总结便辍笔于此。希望八月能轻松一点，也希望能快速脱离这个离谱的横向，摆脱现在实质化的负面情绪，进入新的生活阶段。唉，奈今日茫然，不知明日，波波劫劫，有甚来由？<br></p>]]></content>
    
    
    <categories>
      
      <category>年度总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2024年</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
