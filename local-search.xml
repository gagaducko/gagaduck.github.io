<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(2)—网关</title>
    <link href="/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-2-%E2%80%94%E7%BD%91%E5%85%B3/"/>
    <url>/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-2-%E2%80%94%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务，网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—技术栈实践(1)—注册中心与配置中心</title>
    <link href="/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-1-%E2%80%94%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5-1-%E2%80%94%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br><br>&emsp;&emsp;<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>注册中心</tag>
      
      <tag>配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—微服务—基础知识</title>
    <link href="/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>&emsp;&emsp;首先，要知道什么是微服务，得理解软件架构的演变。<br></p><h2 id="早期单体架构"><a href="#早期单体架构" class="headerlink" title="早期单体架构"></a>早期单体架构</h2><p>&emsp;&emsp;早期的软件，所有的功能都写在一起，整个软件是一个单一的整体，这就是单体架构。<br><br>&emsp;&emsp;单体架构随着软件功能的增加，不可避免的就会就会越来越复杂，存在着许多的缺点<br></p><ul><li>所有功能耦合在一起，互相影响，最终难以管理。</li><li>哪怕只修改一行代码，整个软件就要重新构建和部署，成本非常高。</li><li>因为软件做成了一个整体，不可能每个功能单独开发和测试，只能整体开发和测试，导致必须采用瀑布式的开发模型。</li></ul><p>&emsp;&emsp;简而言之，单体架构的大型软件，不仅开发速度慢，而且会形成难以维护和升级的复杂代码，成为程序员的沉重负担。<br></p><h2 id="面向服务架构（SOA）"><a href="#面向服务架构（SOA）" class="headerlink" title="面向服务架构（SOA）"></a>面向服务架构（SOA）</h2><p>&emsp;&emsp;随之而来的，就是为了解决这些问题，人们提出来，要打破软件代码的耦合，将单体架构的软件拆分成一个个独立的功能单元。<br><br>&emsp;&emsp;大概在二十多年前，随着互联网的出现，功能单元，可以通过远程“服务”的方式来提供，以此诞生出了面向服务架构（service-oriented architecture，简称 SOA）。<br><br>&emsp;&emsp;什么是服务（service）呢？service 就是后台不间断运行、提供某种功能的一个程序。最常见的服务就是 Web 服务，通过80端口向外界提供网页访问。<br><br>&emsp;&emsp;而SOA就是把一个大型的单体程序，拆分成一个个独立服务，也就是说较小的程序，每个程序都是一个独立的功能单元，承担着不同的功能，服务之间通过通信协议连在一起。<br><br>&emsp;&emsp;于此，这种SOA的优点就展现出来了：<br></p><ul><li>每种服务功能单一，相当于一个小型软件，便于开发和测试。</li><li>各个服务独立运行，简化了架构，提高了可靠性。</li><li>鼓励和支持代码重用，同一个服务可以用于多种目的。</li><li>不同服务可以单独开发和部署，便于升级。</li><li>扩展性好，可以容易地加机器、加功能，承受高负载。</li><li>不容易出现单点故障。即使一个服务失败了，不会影响到其他服务。</li></ul><p>&emsp;&emsp;跟单体架构不一样，面向服务架构是语言不敏感的，不同服务可以使用不同的语言和工具开发，可能需要部署在不同的系统和环境。<br><br>&emsp;&emsp;当然这意味着，面向服务架构默认运行在不同服务器上，每台服务器提供一种服务，多台服务器共同组成一个完整的网络应用。<br></p><h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><p>&emsp;&emsp;在有了SOA之后，随着时代的发展，还需要了解这个部署方式的变化。<br><br>&emsp;&emsp;也就是虚拟化技术的发展。虚拟化技术至今已经走过了三个时代，没有容器化技术的演进就没有docker技术的诞生。<br><br>&emsp;&emsp;首先，是物理机时代，一个物理机，一个os，上面可能会跑很多个程序<br><br>&emsp;&emsp;进一步的，是虚拟机时代，一台物理机器安装多个虚拟机，一个虚拟机跑多个程序。<br><br>&emsp;&emsp;再进一步的，就是容器化的时代，一台物理机安装多个容器实例，一个容器跑多个程序。<br><br>&emsp;&emsp;容器化技术的一大优点就是：开发人员编写代码，本地环境是好的，但是部署到测试环境中，坏了，全是bug，环境不同。容器化技术，就是解决了该问题，将软件程序和运行的基础环境分开，开发人员编码完成后，将程序打包到一个容器镜像中去，镜像中详列出所依赖的环境，不同的容器中运行标准化的镜像，从而从根本上解决了环境不一致的问题。可移植性好，占地小，共享bin和lib<br><br>&emsp;&emsp;2014年，docker的出现，改变了软件开发的面貌，它让程序运行在容器中，每个容器可以分别设定运行环境，只需要占用很少的系统资源就可以使用。<br><br>&emsp;&emsp;显而易见，可以用容器来实现”面向服务架构”，每个服务不再占用一台服务器，而是占用一个容器。<br><br>&emsp;&emsp;这样就不需要多台服务器了，最简单的情况下，本机运行多个容器，只用一台服务器就实现了面向服务架构，这在以前是做不到的。这种实现方式就叫做微服务。<br><br>&emsp;&emsp;所以，微服务到底是什么呢？<br><br>&emsp;&emsp;简单说，微服务就是采用容器技术的面向服务架构。它依然使用”服务”作为功能单元，但是变成了轻量级实现，不需要新增服务器，只需要新建容器（一个进程），所以才叫做”微服务”。<br><br>&emsp;&emsp;微服务架构是一种软件架构风格，其中应用程序以一组小型、独立的服务构建，每个服务运行在自己的进程中，并使用轻量级通信机制进行通信。<br><br>&emsp;&emsp;一个微服务就是一个独立的进程。 这个进程可以运行在本机，也可以运行在别的服务器，或者在云端（比如云服务和云函数 FaaS）。<br><br>&emsp;&emsp;它的特点与面向服务架构是一样的，但因为更轻量级，所以功能的解耦和服务化可以做得更彻底。而且，它可以标准化，同样的容器不管在哪里运行，结果都是一样的，所以市场上有很多 SaaS 产品，提供标准化的微服务。<br><br>&emsp;&emsp;正是由于微服务这些突出的优点，这些年才会变得如此流行。它和容器技术、云服务等一起，一定会在未来的软件开发中，扮演越来越重要的角色。<br></p><h2 id="微服务的技术栈"><a href="#微服务的技术栈" class="headerlink" title="微服务的技术栈"></a>微服务的技术栈</h2><h4 id="docker-k8s"><a href="#docker-k8s" class="headerlink" title="docker &amp;&amp; k8s"></a>docker &amp;&amp; k8s</h4><p>&emsp;&emsp;首先，微服务的核心就是容器化技术，每一个微服务都需要以docker或者其他容器的方式进行使用，每一个服务都在一个独立的容器中。<br><br>&emsp;&emsp;2010年一位年轻小伙子在美国旧金山成立了一家名叫【dotCloud】的公司， 开发了 Docker的核心技术，从此开启了容器技术的时代。<br><br>&emsp;&emsp;后面 dotCloud 公司将自己的容器技术进行了简化和标准化，取名为 Docker，就是大家熟悉的鲸鱼 logo。<br><br>&emsp;&emsp;尽管Docker为容器化的应用程序提供了开放标准，但随着容器越来越多出现了一系列新问题：<br></p><ul><li>如何协调和调度这些容器</li><li>如何在升级应用程序的时候不会中断服务</li><li>如何监视应用程序的运行状况</li><li>如何批量重新启动容器内的程序</li></ul><p>&emsp;&emsp;要解决这些问题，就需要容器编排技术，可以将众多的极其抽象，对外呈现出一台超级大机器，比如现在业界流行的k8s。<br><br>&emsp;&emsp;在业务发展初期只有几个微服务，这时用 Docker 就足够了，但随着业务规模逐渐扩大，容器越来越多，运维人员的工作越来越复杂，这个时候就需要编排系统解救运维人员。<br><br>&emsp;&emsp;换言之，在微服务架构中，使用Docker或其他容器打包发布应用，使用kubernetes扩展、运行、监控应用。<br><br>&emsp;&emsp;此外，没有k8s也可以使用docker，k8s非常复杂，在业务比较简单的时候可以放弃使用k8s<br><br>&emsp;&emsp;然而，需要注意的是，k8s是一个容器编排器，没有容器，没法编排。没有docker这类容器，就无法使用k8s，k8s主要还是和docker这些容器进行搭配，当然，其他容器也是可以的，比如Containerd <br></p><h4 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h4><p>&emsp;&emsp;一个微服务架构的重中之重，除了docker就是服务注册与发现。<br><br>&emsp;&emsp;微服务之间才能相互调用完成整体的业务功能，如何在众多的微服务中找到正确的目标服务地址呢，如果服务的IP或者端口变了，那是否就需要对庞大的微服务们进行修改呢，这就需要服务发现的功能。<br><br>&emsp;&emsp;要发现服务，自然首先要注册服务，最常用的做法就是在服务提供者启动的时候就将地址上报给服务注册中心，这就是服务注册。<br><br>&emsp;&emsp;服务调用方通过订阅服务变更的通知，动态的接收到服务注册中心所推送的服务地址列表，想找哪个服务直接发送就可以了。<br><br>&emsp;&emsp;现在Spring Cloud和Spring Cloud Alibaba常用的服务注册与发现工作包括eureka和nacos等。<br></p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>&emsp;&emsp;在微服务架构中，一个微服务可能有很多个实例，每个实例的配置可能都不一样，比如数据库连接地址，数据库用户名密码等，如果每个实例都手动修改，那无疑是非常麻烦的，所以就需要配置管理。<br><br>&emsp;&emsp;配置管理就是将配置信息集中管理，每个实例启动的时候从配置管理中获取配置信息，这样就可以保证每个实例的配置信息都是一致的。<br><br>&emsp;&emsp;配置管理可以使用Spring Cloud Config或者Spring Cloud Alibaba Nacos等。<br></p><h4 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h4><p>&emsp;&emsp;在微服务架构中，一个服务可能会调用多个其他服务，如果其中一个服务出现故障，那么整个服务就会崩溃<br><br>&emsp;&emsp;任何服务都不能保证100%不出问题，生产环境复杂多变，服务运行过程中不可避免的发生各种故障（宕机、过载等等），工程师能够做的是在故障发生时尽可能降低影响范围、尽快恢复正常服务。<br><br>&emsp;&emsp;程序员为了避免被祭天，需要引入「熔断、隔离、限流和降级、超时机制」等「服务容错」的机制来保证服务持续可用性。<br><br>&emsp;&emsp;服务容错可以通过熔断、降级、限流等方式来实现，常用的工具有Hystrix、Sentinel等。<br></p><h4 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h4><p>&emsp;&emsp;在微服务架构中，服务之间的调用纷繁复杂，有些服务的敏感数据存在安全问题，「服务安全」就是对敏感服务采用安全鉴权机制，对服务的访问需要进行相应的身份验证和授权，防止数据泄露的风险，安全是一个长久的话题，在微服务中也有很多工作要做。<br><br>&emsp;&emsp;服务安全可以通过OAuth2、JWT等方式来实现，常用的工具有Spring Security、OAuth2等。<br></p><h4 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h4><p>&emsp;&emsp;在微服务架构中，服务之间的调用纷繁复杂，如果每个服务都暴露自己的API接口，那么调用方就需要知道每个服务的API接口，这无疑是非常麻烦的，所以就需要一个统一的入口，这就是API网关。<br><br>&emsp;&emsp;API网关就是将所有的API接口都集中在一个地方，调用方只需要调用API网关，API网关会根据请求的路径和参数，将请求转发到相应的服务，API网关还可以配合其他工具实现负载均衡、限流、鉴权、动态路由等功能。<br></p><h4 id="服务追踪"><a href="#服务追踪" class="headerlink" title="服务追踪"></a>服务追踪</h4><p>&emsp;&emsp;在微服务架构中，服务之间的调用纷繁复杂，如果出现故障，如何快速定位是哪个服务出现了问题呢？那么就需要定位问题，这就需要服务追踪。<br><br>&emsp;&emsp;服务追踪就是将每个请求的调用链路记录下来，这样就可以根据请求的调用链路来定位问题，常用的工具有Zipkin、SkyWalking等。<br></p><h4 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h4><p>&emsp;&emsp;此外，服务的运行过程难免需要对其性能等内容进行监控，因此，监控也是必不可少的。<br></p><h2 id="微服务的发展"><a href="#微服务的发展" class="headerlink" title="微服务的发展"></a>微服务的发展</h2><p>&emsp;&emsp;2011年，微服务的概念由Netflix等企业提出，他们需要一种更灵活、独立的服务模式，以满足大规模互联网应用的扩展性需求。与SOA相比，微服务是去中心化的，服务更小、独立，且通过HTTP、消息队列等协议通信。<br><br>&emsp;&emsp;2012-2015年：Netflix开源了一系列微服务相关的工具，这些工具构成了微服务生态系统的基础组件。<br></p><ul><li>Eureka（2012）：Netflix推出的服务注册和发现组件，允许微服务在启动时注册，并通过Eureka客户端进行相互发现。</li><li>Hystrix（2012）：Netflix推出的熔断器，用于处理服务调用失败和网络超时。</li><li>Ribbon（2012）：用于负载均衡的组件。</li><li>etc.</li></ul><p>&emsp;&emsp;此外，2014年，Spring Cloud项目正式发布，整合Netflix的微服务工具，简化了Java开发者构建微服务的工作。<br><br>&emsp;&emsp;到2015年，Spring Cloud成为了微服务架构中流行的框架，提供着一整套解决方案，推动了微服务架构的大规模应用。<br><br>&emsp;&emsp;2017年，随着阿里巴巴开源了Nacos，这一款集服务发现、配置管理于一体的组件，替代了eureka的部分功能。Nacos能够提供更加灵活的配置管理和服务注册功能，并且支持AP和CP（即一致性和可用性）的权衡，逐渐在国内流行起来，替代了部分Eureka的使用场景。其他各型组件也是类似情况，替代方案逐渐增加。<br><br>&emsp;&emsp;2014年，Google开源了Kubernetes（简称K8s），这是一个容器编排工具，可以自动化管理容器化应用的部署、伸缩和运维。Kubernetes逐渐成为云原生应用的核心平台。<br><br>&emsp;&emsp;2017年，服务网格（Service Mesh）架构开始流行，Istio成为其代表工具。服务网格将服务间的通信逻辑（如负载均衡、熔断、流量控制等）从应用中剥离，交由一个独立的基础设施层管理。Istio使用Envoy作为数据平面，负责流量管理，而Istio本身作为控制平面。<br><br>&emsp;&emsp;2020年之后，Kubernetes和服务网格技术结合，成为了微服务架构的主流模式。通过Kubernetes进行容器编排，服务网格则负责微服务之间的通信、流量管理、监控和安全。<br><br>&emsp;&emsp;通过Helm这一Kubernetes的包管理工具，简化了应用的部署。<br></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;总的来说呢，微服务架构现在正在变得更加成熟和普及，虽然随着Kubernetes + Istio的流行，传统的微服务框架如Spring Cloud逐渐被替代，但微服务架构的核心思想仍然存在，并且随着技术的不断进步，微服务架构将会变得更加灵活和高效。<br><br>&emsp;&emsp;而原先的框架如Spring Cloud和Spring Cloud Alibaba，其实也有一定的优势，模块丰富，技术成熟，方案完整，在许多场景下也有相当适用的一面。<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>微服务学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记—通过nginx对UDP做负载均衡</title>
    <link href="/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E9%80%9A%E8%BF%87nginx%E5%AF%B9UDP%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <url>/2024/09/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E9%80%9A%E8%BF%87nginx%E5%AF%B9UDP%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在某些场合下，大量的请求对于单个实例来说是很难承受的，有可能会导致服务器宕机。<br><br>&emsp;&emsp;因此，所谓负载均衡，就是要把大量的请求按照指定的方式均衡分配给集群中的每台服务器，从而避免这种情况。<br><br>&emsp;&emsp;做负载的方式有许多，此处针对UDP，通过nginx做负载均衡。<br><br>&emsp;&emsp;实现负载均衡前，首先需要实现反向代理，也就是说，请求到某个宇明的时候，该请求默认是被nginx接收到的，然后nginx根据配置，做解析，把特定的请求转发到对应的服务器上去。如下述代码为nginx.conf的一部分。<br></p><figure class="highlight nginx"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-section">upstream</span> udp_servers &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8081</span>;  <span class="hljs-comment"># 第一个UDP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8082</span>;  <span class="hljs-comment"># 第二个UDP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8083</span>;  <span class="hljs-comment"># 第三个UDP程序实例的地址和端口</span><br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span> udp;<br>        <span class="hljs-attribute">proxy_pass</span> udp_servers;<br>        <span class="hljs-attribute">proxy_responses</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码是用于nginx服务器配置的，定义了一个UDP流量的负载均衡设置。<br><br>&emsp;&emsp;stream{}这一行表示开始定义了一个流模块的配置块，nginx的流模块可以用于处理TCP和UDP流量。<br><br>&emsp;&emsp;upstream udp_servers {}：这一行定义了一个名为udp_servers的上游服务器组。这个组将包含多个UDP服务器实例，用于处理负载均衡。其中包含的就是可以负载过去的实例对象。<br><br>&emsp;&emsp;server 192.168.186.1:8081;：这是定义在udp_servers组中的第一个服务器实例，其IP地址为192.168.186.1，端口为8081。这表示UDP流量可以被发送到这个地址和端口。<br><br>&emsp;&emsp;另外两个同理。<br><br>&emsp;&emsp;server {}：这一行开始定义一个服务器配置块，它将监听特定的端口，并将流量代理到上游服务器。<br><br>&emsp;&emsp;listen 8080 udp;：这一行指定Nginx服务器将监听UDP协议的8080端口。任何到达这个端口的UDP数据包都将被Nginx处理。<br><br>&emsp;&emsp;proxy_pass udp_servers;：这一行指定了将流量代理到之前定义的udp_servers上游服务器组。这意味着Nginx将根据负载均衡算法将UDP数据包发送到组中的服务器。<br><br>&emsp;&emsp;proxy_responses 1;：这一行配置了代理响应的数量。在这里，它被设置为1，意味着Nginx在接收到来自上游服务器的第一个响应后，就会停止处理并返回给客户端。这在某些UDP协议中很有用，比如DNS查询。<br><br>&emsp;&emsp;这样，监听8080端口的UDP流量，就会被分发到三个不同的UDP服务器实例上。<br><br>&emsp;&emsp;HTTP与TCP是类似的。<br><br>&emsp;&emsp;如下为一个包含UDP和同端口的HTTP负载均衡的nginx.conf的示例，在这个配置中，UDP和HTTP流量都配置在一个端口上，但是NGINX可以根据类型正确的分发它们。<br></p><figure class="highlight nginx"><figcaption><span>[title] [lang:language] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-comment"># Stream block for UDP traffic</span><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-section">upstream</span> udp_servers &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8081</span>;  <span class="hljs-comment"># 第一个UDP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8082</span>;  <span class="hljs-comment"># 第二个UDP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8083</span>;  <span class="hljs-comment"># 第三个UDP程序实例的地址和端口</span><br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span> udp;<br>        <span class="hljs-attribute">proxy_pass</span> udp_servers;<br>        <span class="hljs-attribute">proxy_responses</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># HTTP block for HTTP traffic</span><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       /etc/nginx/mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> -<span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] &quot;<span class="hljs-variable">$request</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span><span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;<br><br>    <span class="hljs-attribute">access_log</span>  /var/log/nginx/access.log  main;<br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-comment"># Upstream block for HTTP servers</span><br>    <span class="hljs-section">upstream</span> http_servers &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8081</span>;  <span class="hljs-comment"># 第一个HTTP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8082</span>;  <span class="hljs-comment"># 第二个HTTP程序实例的地址和端口</span><br>        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.186.1:8083</span>;  <span class="hljs-comment"># 第三个HTTP程序实例的地址和端口</span><br>    &#125;<br><br>    <span class="hljs-comment"># Server block for HTTP traffic</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;  <span class="hljs-comment"># 监听8080端口上的HTTP流量</span><br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://http_servers;  <span class="hljs-comment"># 将流量代理到定义的上游服务器</span><br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;     <span class="hljs-comment"># 设置代理头信息</span><br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;  <span class="hljs-comment"># 设置真实客户端IP</span><br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UDP</tag>
      
      <tag>Nginx</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年8月总结</title>
    <link href="/2024/09/02/2024%E5%B9%B48%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <url>/2024/09/02/2024%E5%B9%B48%E6%9C%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;八月过得倒是也快。<br><br>&emsp;&emsp;月初送走了联培的学长学姐，细细想来，多少也算一年的苦友了，倒是有些不舍。<br><br>&emsp;&emsp;现在所谓的学硕是越发少了，而专硕专博的名额反倒是越发多了，一年前，有朋友一直跟我说联培不好，去了联培基地就是当牛马，现在看来，倒也不尽然，若是向下联培，自然就如史湘云入寒窑，这辈子算是有了；但若是向上联培，反倒是刘姥姥进大观园，感叹以前过得是什么苦日子了，也不失为一件美事。尤其是当联培的学长发来其联培的幸福生活的时候，从厂子里回来，弯了一天的腰可算是断了。<br><br>&emsp;&emsp;但与此同时，随着他们的离开，也惊觉八月一整个月都要作为绝对的驻厂主力成员在这依托答辩的横向上来承受痛苦了。<br><br>&emsp;&emsp;正因如此，痛苦，是这个月的主基调。<br><br>&emsp;&emsp;厂子里的氛围是越发压抑了，搞什么敏捷开发，不断加需求变需求，驻厂就驻厂，还被各式各样的人指指点点，每天13小时的工作时长，在监工注视下的高度紧张，做了非常多的活儿，每天都非常的累，看板上的工作反而是越发的多了，真好，这半年来的惨痛生活真是一种另类的芝麻开花了，一天过得比一天惨了。<br><br>&emsp;&emsp;此间有什么细节呢？老实说，不太回忆的起来了，只有痛苦的感觉而没有痛苦的记忆了，也算是一种自我保护机制吧。看着日历，是越发盼望着开学了，这其实是不准确的，盼望着脱离苦海吧。但是，这苦海的源头到底在哪里呢？脱离了这个苦海难道就没有下一个苦海了吗？不好说，也难说。但是难说就应该不说吗？进一步的，难做就应该不做吗？<br><br>&emsp;&emsp;最近看见了童润中的事情，想起了一个不咋熟但是久闻大名的同学。食堂的饭菜难吃了，投诉；买东西缺斤少两了，投诉；看到有恶劣行为，举报。凡此种种，不胜其数，凡是恶事、坏事，容不得一点沙子。虽然听起来正气到很离谱，但是很多时候仔细想想，社会的进步就是靠着这类人一点点往前推动的。这些人是在为众人抱柴，越多自然是越好。<br><br>&emsp;&emsp;我或许没有这么刚的勇气，但这不应该是我退缩的原因，要行动起来，想一些更好的办法，做一些更好的事情。<br><br>&emsp;&emsp;下个月最大的盼望就是能尽快脱离苦海，有充足的时间，没有过于emo的情绪，这是行动的保障，比起时常感慨于自己的牛马生活，或许思考更加的重要，立下一个小小的flag，九月开始，要重新拾起读书思考的老习惯。<br></p>]]></content>
    
    
    <categories>
      
      <category>每月总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2024年</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年年中总结</title>
    <link href="/2024/07/31/2024%E5%B9%B4%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/31/2024%E5%B9%B4%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;想要记录一些东西，倒也不是一时半刻了，只不过，过往时日，话到笔尖，总归是落不下去。<br><br>&emsp;&emsp;去年这个时间点，正值大三结束，待入毕业季，众多选择的十字路口让我陷入了无尽的纠结与焦虑之中。那时候的我，完全没有想象到自己一年后的精神状态与生活状态，会是如此的糟糕。越来越差的记忆力，越来越差的心情，越来越差的身体状况，让我开始怀疑人生，怀疑自己。<br><br>&emsp;&emsp;一年前推免的时候，发生了什么呢？记忆已然模糊了。但那时的心情，却还暂存在胸口，焦虑、迷茫、不安，种种情绪交织在一起，让我无法入睡。即便是有熟悉的朋友向我三番五次强调将要做下的选择，会是何等的光景，我也还是在这复杂的情绪下，迈出了阶段性的一步。<br><br>&emsp;&emsp;或许朋友说的很对。<br><br>&emsp;&emsp;起码，在当下的关头，是对的。<br><br>&emsp;&emsp;这一年来，有一句话，一直刻在我的心头：“选择比努力更重要。”<br><br>&emsp;&emsp;是啊，选择比努力更重要。但是，当选择已经做下，又该如何去面对呢？<br><br>&emsp;&emsp;最近心情一直很差，做许多事情都抬不起兴趣，甚至有些消极。有坏处，但也有好处。心情低落的时候是做不下去主线的，但心情低落的时候，却可以在不断的发呆中审视自己，做一下无关生活主线的事情。近日更是翻到了实验室几年前毕业了的学长写的博客，感慨其长期坚持的毅力同时，却又想起了写学期总结时完全想不起来发生了什么的无奈。<br><br>&emsp;&emsp;既然不想思考了，那便落笔记录一下流水账吧，或许以后会用到。<br><br>&emsp;&emsp;这样想着，便在低落的状态下，开始记录了。<br><br>&emsp;&emsp;第一篇随笔，就借着学期总结，回忆一下过半的2024年吧。<br><br>&emsp;&emsp;一月，开年就是极度不顺利的一个月。实验室的一个横向项目，需要驻厂，用通俗易懂的说法就是，需要学生去厂子里面全天开发。乍一听似乎并不是什么大事儿，毕竟在哪儿干活不是干活呢？不过，这件事情的离谱程度已经远远超出了许多人的想象，容我在接下来的内容中再叙述。对于研一的学长学姐来说，靠着课程，有着充足的理由可以抽身于此，而这份苦差，自然而然就落到了大四，或者说准研一的头上。<br><br>&emsp;&emsp;其实，从去年的12月下旬，这个横向的驻厂开发工作便开始了，如果用一句话来概述：在一个压抑到窒息的环境下，每周三天，蜗居一角，用落后的开发环境，通过“记事本”写代码开发，浪费本就不多的生命。<br><br>&emsp;&emsp;其间细节，出于各种原因，倒也不可多言。但是，保密，我能理解，需要人驻厂，我也能理解；只是，我不能理解，相当恶劣的物理环境，相当抽象的开发环境，相当混乱的项目管理。开始痛苦，过程痛苦，预计结尾更加痛苦；配环境痛苦，开发痛苦，同步痛苦，连吃饭都很痛苦。只能说驻厂真的是非常非常非常痛苦的一个环节，而痛苦的主要原因却并非是能力或者复杂的业务造成的。而且，这段时间的驻厂，干的是什么活呢？物理搬运服务器，物理搬运主机，在离线环境下配置“真·干干净净”的服务器……<br><br>&emsp;&emsp;一月的结尾和二月的开头，是本科最后的寒假。谈不上好，有小一半的时间都在医院里面了，但是在家里总归是好的，和家人在一起，缓和了很大一部分的负面情绪。<br><br>&emsp;&emsp;二月中，开学了，这个学期，开始预先上了两门研究生的课程。选这两门课的目的并不单纯，只是为了也有理由每周可以少去两天横向所在的厂子。自然，对于能否取得这两门课的好成绩，又或者说，去不去上这两门课，倒是都也不重要了，<br><br>&emsp;&emsp;不过，开学了，自然也就意味着上文提到的横向项目，又要开始驻厂了。靠着这两门课，加上研一缓和了很多的课程压力。研一的学长学姐们一周也需要去驻厂个1天半天的了，虽然不多，却是让我每周可以少浪费一天的生命，只需要去两天了。<br><br>&emsp;&emsp;对于身心的折磨，自然，也就重启了。<br><br>&emsp;&emsp;三月，虽然才刚开学，但是对于所上的两门课，已经进入了三天打鱼两天晒网的阶段了。原因很简单，横向的开发进入一个加速阶段了，离谱的甲方开始刷纯在感了。去驻一天的厂，需要花两天的时间来消耗负面情绪和身体的疲惫，想要做什么？太困难了。唯一值得庆幸的是，和我一块去的人，还能聊聊天，总不至于完全陷入自我封闭的状态。<br><br>&emsp;&emsp;四月，情况坏起来了，每周三和每周五，当去到横向的厂子里，便发现怎么这么离谱，全是活？周三去发现联调的进度和上周五相差不大，周五发现和周三相差不大，每天都在火急火燎的干活，精神进入了一个高度紧张的状态。<br><br>&emsp;&emsp;五月，虽然还是要在厂子里面驻厂，但总归是要赶一下毕业论文了。从某个角度上来讲，或许该“感谢”一下这个横向，毕竟毕设的课题来源于此。但是，整个五月，反而是最光怪陆离的。<br><br>&emsp;&emsp;一方面，五月，在厂子里发生了非常多不愉快的事情，同样是出于保密原因，就不多留述了，打一个简单的比方，每天都会有人来看你有没有好好吃💩，没吃或者吃少了，就想方设法喂你一口，真好，怕饿着了；另一方面，在校内写毕设的时间是真短啊，人的精力是有限的，当一件事情占用了你大部分精力的时候，另一件事情就很难兼顾了。不可能说我这段时间加把劲儿，就能多干好多事情，一段时间的精力投入是有上限的，这决定了这段时间能干成干好的事情。<br><br>&emsp;&emsp;五月还必须得感谢一个工程能力很强的学长，靠着他，这个横向才没有挂掉。与此同时，五月，我才从这个横向其他单位的同事那里知道，原来其他的学长，一周其实只轮着去驻厂半天，而且，一驻厂就睡大觉，突然间就明白，为什么每周三和周五工作堆积的这么多了。<br><br>&emsp;&emsp;不过，我并没有觉得这有什么不好，正如上面我所提到的，他们身上被插上的其他事情也很多，精力总归是有限的，在某些事情上摆烂一点，是好事儿。<br><br>&emsp;&emsp;六月，是毕业月。与濒临崩溃的精神状态相衬的是，六月毕业季里校园里弥漫着的毕业气息。本科生活总归是要结束了，这段时间我想了很多，回忆了许多，突然间熟悉的生活就要不再了，对未来却又没有什么期待，进入了一种浑浑噩噩的状态。<br><br>&emsp;&emsp;六月底，我是扛不住了，精神离崩溃只有一步之遥，终于，我在毕业典礼后的一周（七月一号），请假开始了我短暂的两周毕业旅行。头半周在江浙补了许多疫情几年想去却没找到机会的地方。后面则是与好几个班级的朋友去了内蒙古，草原、沙漠，突然间觉得生命好美好，手头的刀又放下了，尽管知道这就像一个短暂的美梦，醒来后还是得面对那个令我痛苦不堪了半年多的横向，我也必须承认，短短两周给我带来的休息效果是非常棒的，生活又有了一点期待，虽然不多。<br><br>&emsp;&emsp;七月开始，是这个牛马横向项目最艰难的时期，甲方开始疯狂催促了，而整个项目还处在一个烂尾的状态。我在六月三十号前，花了小一周时间，把工作和两个学长学姐对接过了，但是当我七月十四号回来的时候，看到的却是几乎完全没有进展的工作情况。<br><br>&emsp;&emsp;我能理解他们，真的。对于一个ToL（To Leader）项目，责任心越重，就会越痛苦，横向做的再好，投入再多的时间，对于学生来说，只是负担加重了，对于权责关系的“权”来说，几乎没有什么帮助。<br><br>&emsp;&emsp;学长们躺平，说明他们不光是意识到了这一点，更是在践行这一点了。在这方面，是值得学习的，躺平，学会踢皮球，“我压力也未尝不大”。<br><br>&emsp;&emsp;不过，单就这个项目来说，总归是要有人做的，七月的后面两周，我开始了大加班。除了驻厂难以开发，白天写晚上写，周内写周末写，总归是很大程度的推进了这个项目，缓和了很大的压力。很难说这个折磨人的横向有没有提升自己的能力，或许是有的，只不过我认为与其付出相较而言，完全不等价。<br><br>&emsp;&emsp;也是这两日，联培的学长们就要走了，实验室长一届的学长学姐一下就只剩下三个了，一时之间，有些恍惚，原来已经一年了啊……<br><br>&emsp;&emsp;半年的总结便辍笔于此。希望八月能轻松一点，也希望能快速脱离这个离谱的横向，摆脱现在实质化的负面情绪，进入新的生活阶段。唉，奈今日茫然，不知明日，波波劫劫，有甚来由？<br></p>]]></content>
    
    
    <categories>
      
      <category>年度总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2024年</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
